import {
  ArrowLeft,
  EllipsisVertical,
  Paperclip,
  Pen,
  Reply,
  Send,
  ShieldX,
  Trash2,
  TriangleAlert,
  Users,
  X
} from "./chunk-2H2TMRBG.js";
import {
  Timestamp,
  addDoc,
  analytics,
  auth,
  collection,
  db,
  deleteDoc,
  doc,
  getDoc,
  getDocs,
  getDownloadURL,
  limit,
  onSnapshot,
  orderBy,
  query,
  ref,
  runTransaction,
  serverTimestamp,
  setDoc,
  storage,
  updateDoc,
  uploadBytes,
  where,
  writeBatch
} from "./chunk-MEVTEXBO.js";
import {
  base44,
  firebaseClient
} from "./chunk-ILM7CXQT.js";
import {
  createUserWithEmailAndPassword,
  onAuthStateChanged,
  signInWithEmailAndPassword,
  signOut,
  updateProfile
} from "./chunk-EPFT6GZP.js";
import {
  require_jsx_runtime
} from "./chunk-6PXSGDAH.js";
import {
  Navigate
} from "./chunk-YYBKJP6A.js";
import "./chunk-NXESFFTV.js";
import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// shared/contexts/AuthContext.tsx
var import_react = __toESM(require_react());

// shared/api/entities/AppUser.js
var filter = (filters = {}, limit2 = null) => firebaseClient.entities.AppUser.filter(filters, limit2);
var update = (id, data) => firebaseClient.entities.AppUser.update(id, data);

// shared/utils/routing.ts
var APP_CONFIGS = {
  "o7c-hub": {
    name: "O7C Hub",
    url: false ? "https://o7c-hub.vercel.app" : "http://localhost:3000",
    allowedRoles: ["admin", "coach"],
    defaultRoute: "/"
  },
  "player-portal": {
    name: "Player Portal",
    url: false ? "https://player-portal.vercel.app" : "http://localhost:3001",
    allowedRoles: ["player", "parent"],
    defaultRoute: "/"
  }
};
var getAppForRole = (role) => {
  if (["admin", "coach"].includes(role)) {
    return "o7c-hub";
  }
  if (["player", "parent"].includes(role)) {
    return "player-portal";
  }
  return "player-portal";
};
var getRedirectUrl = (role) => {
  const appKey = getAppForRole(role);
  const appConfig = APP_CONFIGS[appKey];
  return appConfig ? appConfig.url + appConfig.defaultRoute : APP_CONFIGS["player-portal"].url;
};
var hasAccessToApp = (role, appKey) => {
  const appConfig = APP_CONFIGS[appKey];
  return appConfig ? appConfig.allowedRoles.includes(role) : false;
};
var getCurrentApp = () => {
  const hostname = window.location.hostname;
  const port = window.location.port;
  if (hostname.includes("o7c-hub") || port === "3000") {
    return "o7c-hub";
  }
  if (hostname.includes("player-portal") || port === "3001") {
    return "player-portal";
  }
  return "player-portal";
};
var shouldRedirectUser = (userRole) => {
  const currentApp = getCurrentApp();
  return !hasAccessToApp(userRole, currentApp);
};

// shared/contexts/AuthContext.tsx
var import_jsx_runtime = __toESM(require_jsx_runtime());
var AuthContext = (0, import_react.createContext)(void 0);
var useAuth = () => {
  const context = (0, import_react.useContext)(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
};
var AuthProvider = ({ children }) => {
  const [user, setUser] = (0, import_react.useState)(null);
  const [loading, setLoading] = (0, import_react.useState)(true);
  const [userData, setUserData] = (0, import_react.useState)(null);
  const [userDataLoading, setUserDataLoading] = (0, import_react.useState)(false);
  const fetchUserData = async (firebaseUid) => {
    try {
      setUserDataLoading(true);
      if (!firebaseUid) {
        console.warn("No Firebase UID provided for user data fetch");
        setUserData(null);
        return null;
      }
      const users = await filter({ firebaseUid });
      if (users && users.length > 0) {
        setUserData(users[0]);
        return users[0];
      } else {
        const adminEmails2 = ["leadond@gmail.com", "kleadon11@gmail.com"];
        if (user && adminEmails2.includes(user.email)) {
          const emailUsers = await filter({ email: user.email });
          if (emailUsers && emailUsers.length > 0) {
            const adminUser = emailUsers[0];
            await update(adminUser.id, { firebaseUid });
            setUserData({ ...adminUser, firebaseUid });
            return { ...adminUser, firebaseUid };
          } else {
            setUserData(null);
            return null;
          }
        } else {
          setUserData(null);
          return null;
        }
      }
    } catch (error) {
      console.error("Error fetching user data:", error);
      if (true) {
        const port = window.location.port;
        const role = port === "3001" ? "player" : "admin";
        const mockUserData = {
          id: firebaseUid,
          role,
          status: "approved",
          email: (user == null ? void 0 : user.email) || (port === "3001" ? "player@example.com" : "admin@example.com"),
          name: port === "3001" ? "Development Player" : "Development Admin"
        };
        setUserData(mockUserData);
        return mockUserData;
      }
      setUserData(null);
      return null;
    } finally {
      setUserDataLoading(false);
    }
  };
  (0, import_react.useEffect)(() => {
    if (!auth) {
      console.error("Firebase auth not available. Please check your Firebase configuration.");
      setLoading(false);
      return;
    }
    const unsubscribe = onAuthStateChanged(auth, async (user2) => {
      setUser(user2);
      if (user2) {
        await fetchUserData(user2.uid);
        const userData2 = await fetchUserData(user2.uid);
        if (false) {
          const redirectUrl = getRedirectUrl2(userData2.role);
          if (window.location.href !== redirectUrl) {
            window.location.href = redirectUrl;
            return;
          }
        }
      } else {
        setUserData(null);
      }
      setLoading(false);
    });
    const timeout = setTimeout(() => {
      console.warn("Auth initialization timeout. Check Firebase configuration.");
      setLoading(false);
    }, 5e3);
    return () => {
      unsubscribe();
      clearTimeout(timeout);
    };
  }, []);
  const login = async (email, password) => {
    if (!auth) {
      throw new Error("Firebase authentication is not available. Please check your Firebase configuration.");
    }
    try {
      const userCredential = await signInWithEmailAndPassword(auth, email, password);
      const user2 = userCredential.user;
      if (user2) {
        const refreshedUserData = await fetchUserData(user2.uid);
        return { user: user2, userData: refreshedUserData };
      }
      return { user: null, userData: null };
    } catch (error) {
      console.error("Firebase login error:", error);
      throw error;
    }
  };
  const signup = async (email, password, firstName, lastName, role = "player") => {
    if (!auth) {
      throw new Error("Firebase authentication is not available. Please check your Firebase configuration.");
    }
    try {
      const userCredential = await createUserWithEmailAndPassword(auth, email, password);
      const user2 = userCredential.user;
      if (user2) {
        await updateProfile(user2, {
          displayName: `${firstName} ${lastName}`
        });
        const newUserData = {
          email,
          firstName,
          lastName,
          role,
          firebaseUid: user2.uid
        };
        setUserData(newUserData);
        return { user: user2, userData: newUserData };
      }
      return { user: null, userData: null };
    } catch (error) {
      console.error("Firebase signup error:", error);
      throw error;
    }
  };
  const logout = async () => {
    if (!auth) {
      console.warn("Firebase auth not available. Clearing mock session.");
      setUser(null);
      setUserData(null);
      return;
    }
    await signOut(auth);
  };
  const adminEmails = ["leadond@gmail.com", "kleadon11@gmail.com"];
  const isAdminEmail = user ? adminEmails.includes(user.email) : false;
  const isAuthorized = userData ? userData.status === "approved" && !!userData.role || userData.status !== "pending" && !!userData.role : isAdminEmail;
  const value = {
    user,
    loading,
    userData,
    userDataLoading,
    isAuthorized,
    login,
    signup,
    logout
  };
  return (0, import_jsx_runtime.jsx)(AuthContext.Provider, { value, children: !loading && !userDataLoading && children });
};

// shared/components/ui/button.jsx
var React3 = __toESM(require_react());

// node_modules/@radix-ui/react-slot/dist/index.mjs
var React2 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var React = __toESM(require_react(), 1);
function setRef(ref2, value) {
  if (typeof ref2 === "function") {
    return ref2(value);
  } else if (ref2 !== null && ref2 !== void 0) {
    ref2.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref2) => {
      const cleanup = setRef(ref2, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i = 0; i < cleanups.length; i++) {
          const cleanup = cleanups[i];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i], null);
          }
        }
      };
    }
  };
}

// node_modules/@radix-ui/react-slot/dist/index.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
function createSlot(ownerName) {
  const SlotClone = createSlotClone(ownerName);
  const Slot2 = React2.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = React2.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React2.Children.count(newElement) > 1) return React2.Children.only(null);
          return React2.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return (0, import_jsx_runtime2.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React2.isValidElement(newElement) ? React2.cloneElement(newElement, void 0, newChildren) : null });
    }
    return (0, import_jsx_runtime2.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
var Slot = createSlot("Slot");
function createSlotClone(ownerName) {
  const SlotClone = React2.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (React2.isValidElement(children)) {
      const childrenRef = getElementRef(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== React2.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React2.cloneElement(children, props2);
    }
    return React2.Children.count(children) > 1 ? React2.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function createSlottable(ownerName) {
  const Slottable2 = ({ children }) => {
    return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children });
  };
  Slottable2.displayName = `${ownerName}.Slottable`;
  Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
  return Slottable2;
}
var Slottable = createSlottable("Slottable");
function isSlottable(child) {
  return React2.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}

// node_modules/class-variance-authority/dist/index.mjs
var falsyToString = (value) => typeof value === "boolean" ? `${value}` : value === 0 ? "0" : value;
var cx = clsx;
var cva = (base, config) => (props) => {
  var _config_compoundVariants;
  if ((config === null || config === void 0 ? void 0 : config.variants) == null) return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
  const { variants, defaultVariants } = config;
  const getVariantClassNames = Object.keys(variants).map((variant) => {
    const variantProp = props === null || props === void 0 ? void 0 : props[variant];
    const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
    if (variantProp === null) return null;
    const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
    return variants[variant][variantKey];
  });
  const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param) => {
    let [key, value] = param;
    if (value === void 0) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
  const getCompoundVariantClassNames = config === null || config === void 0 ? void 0 : (_config_compoundVariants = config.compoundVariants) === null || _config_compoundVariants === void 0 ? void 0 : _config_compoundVariants.reduce((acc, param) => {
    let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;
    return Object.entries(compoundVariantOptions).every((param2) => {
      let [key, value] = param2;
      return Array.isArray(value) ? value.includes({
        ...defaultVariants,
        ...propsWithoutUndefined
      }[key]) : {
        ...defaultVariants,
        ...propsWithoutUndefined
      }[key] === value;
    }) ? [
      ...acc,
      cvClass,
      cvClassName
    ] : acc;
  }, []);
  return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
};

// shared/utils/permissions.ts
var PERMISSIONS = [
  // O7C Hub permissions (admin/coach)
  { resource: "dashboard", action: "view", roles: ["admin", "coach"] },
  { resource: "roster", action: "view", roles: ["admin", "coach"] },
  { resource: "roster", action: "manage", roles: ["admin", "coach"] },
  { resource: "recruiting", action: "view", roles: ["admin", "coach"] },
  { resource: "recruiting", action: "manage", roles: ["admin", "coach"] },
  { resource: "users", action: "view", roles: ["admin"] },
  { resource: "users", action: "manage", roles: ["admin"] },
  // Player Portal permissions (player/parent)
  { resource: "profile", action: "view", roles: ["player", "parent"] },
  { resource: "profile", action: "manage", roles: ["player", "parent"] },
  { resource: "recruiting", action: "view", roles: ["player", "parent"] },
  { resource: "calendar", action: "view", roles: ["player", "parent"] },
  { resource: "messages", action: "view", roles: ["player", "parent"] },
  { resource: "messages", action: "manage", roles: ["player", "parent"] },
  { resource: "players", action: "view", roles: ["parent"] },
  { resource: "players", action: "manage", roles: ["parent"] }
];
var hasPermission = (userRole, resource, action) => {
  if (!userRole) return false;
  return PERMISSIONS.some(
    (permission) => permission.resource === resource && permission.action === action && permission.roles.includes(userRole)
  );
};
var hasAnyPermission = (userRole, permissions) => {
  if (!userRole) return false;
  return permissions.some(
    ({ resource, action }) => hasPermission(userRole, resource, action)
  );
};
var hasAllPermissions = (userRole, permissions) => {
  if (!userRole) return false;
  return permissions.every(
    ({ resource, action }) => hasPermission(userRole, resource, action)
  );
};
var getAllowedRoles = (resource, action) => {
  return PERMISSIONS.filter((permission) => permission.resource === resource && permission.action === action).flatMap((permission) => permission.roles);
};

// shared/utils/security.ts
var checkAppAccess = (userRole) => {
  const currentApp = getCurrentApp();
  const hasAccess = hasAccessToApp(userRole, currentApp);
  if (!hasAccess) {
    return {
      allowed: false,
      reason: `User with role '${userRole}' does not have access to '${currentApp}' app`,
      redirectUrl: getRedirectUrlForRole(userRole)
    };
  }
  return { allowed: true };
};
var getRedirectUrlForRole = (userRole) => {
  if (["admin", "coach"].includes(userRole)) {
    return false ? "https://o7c-hub.vercel.app" : "http://localhost:3000";
  }
  if (["player", "parent"].includes(userRole)) {
    return false ? "https://player-portal.vercel.app" : "http://localhost:3001";
  }
  return false ? "https://player-portal.vercel.app" : "http://localhost:3001";
};
var validateApiAccess = (userRole, requiredRoles, endpoint) => {
  if (!userRole) {
    return {
      allowed: false,
      reason: "Authentication required"
    };
  }
  const hasAccess = requiredRoles.includes(userRole);
  if (!hasAccess) {
    return {
      allowed: false,
      reason: `User role '${userRole}' does not have access to endpoint '${endpoint}'. Required roles: ${requiredRoles.join(", ")}`
    };
  }
  return { allowed: true };
};
var canPerformAction = (userRole, resource, action, context) => {
  if (!userRole) {
    return {
      allowed: false,
      reason: "Authentication required"
    };
  }
  const permissions = {
    "user-management": {
      "view": ["admin"],
      "create": ["admin"],
      "update": ["admin"],
      "delete": ["admin"]
    },
    "roster": {
      "view": ["admin", "coach"],
      "manage": ["admin", "coach"]
    },
    "recruiting": {
      "view": ["admin", "coach", "player", "parent"],
      "manage": ["admin", "coach"]
    },
    "profile": {
      "view": ["admin", "coach", "player", "parent"],
      "manage": ["admin", "coach", "player", "parent"]
    },
    "calendar": {
      "view": ["admin", "coach", "player", "parent"],
      "manage": ["admin", "coach"]
    },
    "messages": {
      "view": ["admin", "coach", "player", "parent"],
      "manage": ["admin", "coach", "player", "parent"]
    },
    "players": {
      "view": ["admin", "coach", "parent"],
      "manage": ["admin", "coach", "parent"]
    }
  };
  const resourcePermissions = permissions[resource];
  if (!resourcePermissions) {
    return {
      allowed: false,
      reason: `Unknown resource '${resource}'`
    };
  }
  const actionRoles = resourcePermissions[action];
  if (!actionRoles) {
    return {
      allowed: false,
      reason: `Unknown action '${action}' for resource '${resource}'`
    };
  }
  const hasPermission3 = actionRoles.includes(userRole);
  if (!hasPermission3) {
    return {
      allowed: false,
      reason: `User role '${userRole}' does not have permission to '${action}' resource '${resource}'`
    };
  }
  return { allowed: true };
};
var sanitizeInput = (input) => {
  return input.replace(/</g, "<").replace(/>/g, ">").replace(/"/g, '"').replace(/'/g, "&#x27;").replace(/\//g, "&#x2F;");
};
var isValidEmail = (email) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};
var RateLimiter = class {
  constructor(maxAttempts = 5, windowMs = 15 * 60 * 1e3) {
    this.attempts = /* @__PURE__ */ new Map();
    this.maxAttempts = maxAttempts;
    this.windowMs = windowMs;
  }
  isAllowed(identifier) {
    const now = Date.now();
    const record = this.attempts.get(identifier);
    if (!record || now > record.resetTime) {
      this.attempts.set(identifier, { count: 1, resetTime: now + this.windowMs });
      return true;
    }
    if (record.count >= this.maxAttempts) {
      return false;
    }
    record.count++;
    return true;
  }
  reset(identifier) {
    this.attempts.delete(identifier);
  }
};

// shared/utils/cn.ts
function cn(...inputs) {
  return inputs.filter(Boolean).join(" ");
}

// shared/components/ui/button.jsx
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline: "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
var Button = React3.forwardRef(({ className, variant, size, asChild = false, ...props }, ref2) => {
  const Comp = asChild ? Slot : "button";
  return (0, import_jsx_runtime3.jsx)(
    Comp,
    {
      className: cn(buttonVariants({ variant, size, className })),
      ref: ref2,
      ...props
    }
  );
});
Button.displayName = "Button";

// shared/components/ui/card.jsx
var React4 = __toESM(require_react());
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var Card = React4.forwardRef(({ className, ...props }, ref2) => (0, import_jsx_runtime4.jsx)(
  "div",
  {
    ref: ref2,
    className: cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    ),
    ...props
  }
));
Card.displayName = "Card";
var CardHeader = React4.forwardRef(({ className, ...props }, ref2) => (0, import_jsx_runtime4.jsx)(
  "div",
  {
    ref: ref2,
    className: cn("flex flex-col space-y-1.5 p-6", className),
    ...props
  }
));
CardHeader.displayName = "CardHeader";
var CardTitle = React4.forwardRef(({ className, ...props }, ref2) => (0, import_jsx_runtime4.jsx)(
  "h3",
  {
    ref: ref2,
    className: cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    ),
    ...props
  }
));
CardTitle.displayName = "CardTitle";
var CardDescription = React4.forwardRef(({ className, ...props }, ref2) => (0, import_jsx_runtime4.jsx)(
  "p",
  {
    ref: ref2,
    className: cn("text-sm text-muted-foreground", className),
    ...props
  }
));
CardDescription.displayName = "CardDescription";
var CardContent = React4.forwardRef(({ className, ...props }, ref2) => (0, import_jsx_runtime4.jsx)("div", { ref: ref2, className: cn("p-6 pt-0", className), ...props }));
CardContent.displayName = "CardContent";
var CardFooter = React4.forwardRef(({ className, ...props }, ref2) => (0, import_jsx_runtime4.jsx)(
  "div",
  {
    ref: ref2,
    className: cn("flex items-center p-6 pt-0", className),
    ...props
  }
));
CardFooter.displayName = "CardFooter";

// shared/components/LoadingSpinner.tsx
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var LoadingSpinner = ({
  size = "md",
  message = "Loading...",
  className = ""
}) => {
  const sizeClasses = {
    sm: "h-4 w-4",
    md: "h-8 w-8",
    lg: "h-12 w-12"
  };
  return (0, import_jsx_runtime5.jsxs)("div", { className: `flex flex-col items-center justify-center p-4 ${className}`, children: [
    (0, import_jsx_runtime5.jsx)(
      "div",
      {
        className: `animate-spin rounded-full border-b-2 border-blue-600 ${sizeClasses[size]}`,
        role: "status",
        "aria-label": "Loading"
      }
    ),
    message && (0, import_jsx_runtime5.jsx)("p", { className: "mt-2 text-sm text-gray-600", children: message })
  ] });
};
var LoadingSpinner_default = LoadingSpinner;

// shared/components/AccessDenied.tsx
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var AccessDenied = ({
  title = "Access Denied",
  message = "You don't have permission to access this page.",
  showBackButton = true,
  onBack,
  className = ""
}) => {
  const handleBack = () => {
    if (onBack) {
      onBack();
    } else {
      window.history.back();
    }
  };
  return (0, import_jsx_runtime6.jsx)("div", { className: `min-h-screen flex items-center justify-center bg-gray-50 ${className}`, children: (0, import_jsx_runtime6.jsxs)("div", { className: "max-w-md w-full bg-white rounded-lg shadow-lg p-8 text-center", children: [
    (0, import_jsx_runtime6.jsx)("div", { className: "flex justify-center mb-6", children: (0, import_jsx_runtime6.jsx)(ShieldX, { className: "h-16 w-16 text-red-500" }) }),
    (0, import_jsx_runtime6.jsx)("h1", { className: "text-2xl font-bold text-gray-900 mb-4", children: title }),
    (0, import_jsx_runtime6.jsx)("p", { className: "text-gray-600 mb-8", children: message }),
    showBackButton && (0, import_jsx_runtime6.jsxs)(
      "button",
      {
        onClick: handleBack,
        className: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500",
        children: [
          (0, import_jsx_runtime6.jsx)(ArrowLeft, { className: "w-4 h-4 mr-2" }),
          "Go Back"
        ]
      }
    )
  ] }) });
};
var AccessDenied_default = AccessDenied;

// shared/components/ProtectedRoute.tsx
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var ProtectedRoute = ({
  children,
  allowedRoles = [],
  requiredPermissions = [],
  requireAllPermissions = false,
  fallbackRoute
}) => {
  const { user, userData, loading, userDataLoading } = useAuth();
  if (loading || userDataLoading) {
    return (0, import_jsx_runtime7.jsx)(LoadingSpinner_default, { size: "lg", message: "Checking permissions..." });
  }
  if (!user) {
    return (0, import_jsx_runtime7.jsx)(Navigate, { to: "/", replace: true });
  }
  if (!userData) {
    return (0, import_jsx_runtime7.jsx)(
      AccessDenied_default,
      {
        title: "Account Setup Required",
        message: "Your account is being configured. Please contact support if this persists.",
        showBackButton: false
      }
    );
  }
  if (shouldRedirectUser(userData.role)) {
    const redirectUrl = getRedirectUrl(userData.role);
    window.location.href = redirectUrl;
    return null;
  }
  if (allowedRoles.length > 0 && !allowedRoles.includes(userData.role)) {
    if (fallbackRoute) {
      return (0, import_jsx_runtime7.jsx)(Navigate, { to: fallbackRoute, replace: true });
    }
    return (0, import_jsx_runtime7.jsx)(AccessDenied_default, {});
  }
  if (requiredPermissions.length > 0) {
    const hasRequiredPermissions = requireAllPermissions ? hasAnyPermission(userData.role, requiredPermissions) : hasAnyPermission(userData.role, requiredPermissions);
    if (!hasRequiredPermissions) {
      if (fallbackRoute) {
        return (0, import_jsx_runtime7.jsx)(Navigate, { to: fallbackRoute, replace: true });
      }
      return (0, import_jsx_runtime7.jsx)(
        AccessDenied_default,
        {
          message: "You don't have the required permissions to access this page."
        }
      );
    }
  }
  return (0, import_jsx_runtime7.jsx)(import_jsx_runtime7.Fragment, { children });
};
var ProtectedRoute_default = ProtectedRoute;

// shared/components/ErrorMessage.tsx
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var ErrorMessage = ({
  title = "Error",
  message,
  onClose,
  className = ""
}) => {
  return (0, import_jsx_runtime8.jsx)("div", { className: `bg-red-50 border border-red-200 rounded-md p-4 ${className}`, children: (0, import_jsx_runtime8.jsxs)("div", { className: "flex", children: [
    (0, import_jsx_runtime8.jsx)("div", { className: "flex-shrink-0", children: (0, import_jsx_runtime8.jsx)(TriangleAlert, { className: "h-5 w-5 text-red-400" }) }),
    (0, import_jsx_runtime8.jsxs)("div", { className: "ml-3 flex-1", children: [
      (0, import_jsx_runtime8.jsx)("h3", { className: "text-sm font-medium text-red-800", children: title }),
      (0, import_jsx_runtime8.jsx)("p", { className: "mt-1 text-sm text-red-700", children: message })
    ] }),
    onClose && (0, import_jsx_runtime8.jsx)("div", { className: "ml-auto pl-3", children: (0, import_jsx_runtime8.jsx)(
      "button",
      {
        onClick: onClose,
        className: "inline-flex rounded-md bg-red-50 p-1.5 text-red-500 hover:bg-red-100 focus:outline-none focus:ring-2 focus:ring-red-600 focus:ring-offset-2",
        title: "Close error message",
        children: (0, import_jsx_runtime8.jsx)(X, { className: "h-5 w-5" })
      }
    ) })
  ] }) });
};
var ErrorMessage_default = ErrorMessage;

// shared/components/ChatSystem.tsx
var import_react5 = __toESM(require_react());

// shared/hooks/useChat.ts
var import_react2 = __toESM(require_react());
var useChat = (chatService, userId, userName, userRole) => {
  const [currentRoom, setCurrentRoom] = (0, import_react2.useState)(null);
  const [messages, setMessages] = (0, import_react2.useState)([]);
  const [participants, setParticipants] = (0, import_react2.useState)([]);
  const [isLoading, setIsLoading] = (0, import_react2.useState)(false);
  const [error, setError] = (0, import_react2.useState)(null);
  const [permissions, setPermissions] = (0, import_react2.useState)({
    canSendMessages: false,
    canEditMessages: false,
    canDeleteMessages: false,
    canAddParticipants: false,
    canRemoveParticipants: false,
    canViewHistory: false
  });
  const unsubscribeRefs = (0, import_react2.useRef)([]);
  const sendMessage = (0, import_react2.useCallback)(async (content, type = "text", replyTo) => {
    if (!currentRoom || !permissions.canSendMessages) {
      throw new Error("Cannot send message");
    }
    try {
      setError(null);
      await chatService.sendMessage(currentRoom.id, userId, userName, content, type, replyTo);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to send message");
      throw err;
    }
  }, [currentRoom, permissions.canSendMessages, userId, userName, chatService]);
  const editMessage = (0, import_react2.useCallback)(async (messageId, content) => {
    if (!permissions.canEditMessages) {
      throw new Error("Cannot edit message");
    }
    try {
      setError(null);
      await chatService.editMessage(messageId, content);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to edit message");
      throw err;
    }
  }, [permissions.canEditMessages, chatService]);
  const deleteMessage = (0, import_react2.useCallback)(async (messageId) => {
    if (!permissions.canDeleteMessages) {
      throw new Error("Cannot delete message");
    }
    try {
      setError(null);
      await chatService.deleteMessage(messageId);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to delete message");
      throw err;
    }
  }, [permissions.canDeleteMessages, chatService]);
  const joinRoom = (0, import_react2.useCallback)(async (roomId) => {
    try {
      setIsLoading(true);
      setError(null);
      if (currentRoom) {
        await chatService.leaveRoom(currentRoom.id, userId);
      }
      await chatService.joinRoom(roomId, userId, userName, userRole);
      const roomPermissions = await chatService.getPermissions(userId, roomId);
      setPermissions(roomPermissions);
      setIsLoading(false);
    } catch (err) {
      setIsLoading(false);
      setError(err instanceof Error ? err.message : "Failed to join room");
      throw err;
    }
  }, [currentRoom, userId, userName, userRole, chatService]);
  const leaveRoom = (0, import_react2.useCallback)(async () => {
    if (!currentRoom) return;
    try {
      await chatService.leaveRoom(currentRoom.id, userId);
      setCurrentRoom(null);
      setMessages([]);
      setParticipants([]);
      setPermissions({
        canSendMessages: false,
        canEditMessages: false,
        canDeleteMessages: false,
        canAddParticipants: false,
        canRemoveParticipants: false,
        canViewHistory: false
      });
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to leave room");
    }
  }, [currentRoom, userId, chatService]);
  const loadMoreMessages = (0, import_react2.useCallback)(async () => {
  }, []);
  const markAsRead = (0, import_react2.useCallback)(async (messageId) => {
  }, []);
  (0, import_react2.useEffect)(() => {
    if (!currentRoom) return;
    unsubscribeRefs.current.forEach((unsubscribe) => unsubscribe());
    unsubscribeRefs.current = [];
    const unsubscribeMessages = chatService.subscribeToRoom(currentRoom.id, (newMessages) => {
      setMessages(newMessages);
    });
    unsubscribeRefs.current.push(unsubscribeMessages);
    const unsubscribeRoom = chatService.subscribeToRoomUpdates(currentRoom.id, (room) => {
      setCurrentRoom(room);
      setParticipants(room.participants);
    });
    unsubscribeRefs.current.push(unsubscribeRoom);
    return () => {
      unsubscribeRefs.current.forEach((unsubscribe) => unsubscribe());
      unsubscribeRefs.current = [];
    };
  }, [currentRoom, chatService]);
  (0, import_react2.useEffect)(() => {
    return () => {
      if (currentRoom) {
        chatService.leaveRoom(currentRoom.id, userId).catch(console.error);
      }
      unsubscribeRefs.current.forEach((unsubscribe) => unsubscribe());
    };
  }, [currentRoom, userId, chatService]);
  const contextValue = {
    currentRoom,
    messages,
    participants,
    isLoading,
    error,
    sendMessage,
    editMessage,
    deleteMessage,
    joinRoom,
    leaveRoom,
    loadMoreMessages,
    markAsRead,
    permissions
  };
  return contextValue;
};

// shared/hooks/usePresence.ts
var import_react3 = __toESM(require_react());
var usePresence = (chatService) => {
  const [presences, setPresences] = (0, import_react3.useState)([]);
  const [isLoading, setIsLoading] = (0, import_react3.useState)(true);
  (0, import_react3.useEffect)(() => {
    const unsubscribe = chatService.subscribeToPresence((newPresences) => {
      setPresences(newPresences);
      setIsLoading(false);
    });
    return unsubscribe;
  }, [chatService]);
  const getPresenceByUserId = (0, import_react3.useCallback)((userId) => {
    return presences.find((p) => p.userId === userId);
  }, [presences]);
  const getOnlineUsers = (0, import_react3.useCallback)(() => {
    return presences.filter((p) => p.isOnline);
  }, [presences]);
  const getUsersInRoom = (0, import_react3.useCallback)((roomId) => {
    return presences.filter((p) => p.isOnline && p.currentRoom === roomId);
  }, [presences]);
  return {
    presences,
    isLoading,
    getPresenceByUserId,
    getOnlineUsers,
    getUsersInRoom
  };
};

// shared/hooks/useOfflineQueue.ts
var import_react4 = __toESM(require_react());
var useOfflineQueue = () => {
  const [queue, setQueue] = (0, import_react4.useState)([]);
  const [isOnline, setIsOnline] = (0, import_react4.useState)(navigator.onLine);
  (0, import_react4.useEffect)(() => {
    const savedQueue = localStorage.getItem("chat_offline_queue");
    if (savedQueue) {
      try {
        setQueue(JSON.parse(savedQueue));
      } catch (error) {
        console.error("Failed to parse offline queue:", error);
      }
    }
  }, []);
  (0, import_react4.useEffect)(() => {
    localStorage.setItem("chat_offline_queue", JSON.stringify(queue));
  }, [queue]);
  (0, import_react4.useEffect)(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);
    window.addEventListener("online", handleOnline);
    window.addEventListener("offline", handleOffline);
    return () => {
      window.removeEventListener("online", handleOnline);
      window.removeEventListener("offline", handleOffline);
    };
  }, []);
  const addToQueue = (0, import_react4.useCallback)((roomId, content, type = "text", replyTo) => {
    const queuedMessage = {
      id: `offline_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      roomId,
      content,
      type,
      replyTo,
      timestamp: Date.now(),
      retryCount: 0
    };
    setQueue((prev) => [...prev, queuedMessage]);
    return queuedMessage.id;
  }, []);
  const removeFromQueue = (0, import_react4.useCallback)((messageId) => {
    setQueue((prev) => prev.filter((msg) => msg.id !== messageId));
  }, []);
  const retryMessage = (0, import_react4.useCallback)((messageId) => {
    setQueue((prev) => prev.map(
      (msg) => msg.id === messageId ? { ...msg, retryCount: msg.retryCount + 1 } : msg
    ));
  }, []);
  const clearOldMessages = (0, import_react4.useCallback)(() => {
    const oneDayAgo = Date.now() - 24 * 60 * 60 * 1e3;
    setQueue((prev) => prev.filter((msg) => msg.timestamp > oneDayAgo));
  }, []);
  const getQueuedMessagesForRoom = (0, import_react4.useCallback)((roomId) => {
    return queue.filter((msg) => msg.roomId === roomId);
  }, [queue]);
  const getAllQueuedMessages = (0, import_react4.useCallback)(() => {
    return queue;
  }, [queue]);
  const clearQueue = (0, import_react4.useCallback)(() => {
    setQueue([]);
  }, []);
  const getQueueStats = (0, import_react4.useCallback)(() => {
    return {
      total: queue.length,
      byRoom: queue.reduce((acc, msg) => {
        acc[msg.roomId] = (acc[msg.roomId] || 0) + 1;
        return acc;
      }, {}),
      failedRetries: queue.filter((msg) => msg.retryCount >= 3).length
    };
  }, [queue]);
  return {
    queue,
    isOnline,
    addToQueue,
    removeFromQueue,
    retryMessage,
    clearOldMessages,
    getQueuedMessagesForRoom,
    getAllQueuedMessages,
    clearQueue,
    getQueueStats
  };
};

// shared/components/ChatSystem.tsx
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var ChatSystem = ({
  chatService,
  userId,
  userName,
  userRole,
  roomId,
  className = ""
}) => {
  var _a;
  const [messageInput, setMessageInput] = (0, import_react5.useState)("");
  const [editingMessage, setEditingMessage] = (0, import_react5.useState)(null);
  const [replyingTo, setReplyingTo] = (0, import_react5.useState)(null);
  const [showRoomSelector, setShowRoomSelector] = (0, import_react5.useState)(false);
  const messagesEndRef = (0, import_react5.useRef)(null);
  const fileInputRef = (0, import_react5.useRef)(null);
  const chat = useChat(chatService, userId, userName, userRole);
  const presence = usePresence(chatService);
  (0, import_react5.useEffect)(() => {
    if (roomId && !chat.currentRoom) {
      chat.joinRoom(roomId);
    }
  }, [roomId, chat]);
  (0, import_react5.useEffect)(() => {
    var _a2;
    (_a2 = messagesEndRef.current) == null ? void 0 : _a2.scrollIntoView({ behavior: "smooth" });
  }, [chat.messages]);
  const handleSendMessage = async (e) => {
    e.preventDefault();
    if (!messageInput.trim()) return;
    try {
      if (editingMessage) {
        await chat.editMessage(editingMessage, messageInput);
        setEditingMessage(null);
      } else {
        await chat.sendMessage(messageInput, "text", replyingTo || void 0);
        setReplyingTo(null);
      }
      setMessageInput("");
    } catch (error) {
      console.error("Failed to send message:", error);
    }
  };
  const handleFileUpload = async (e) => {
    var _a2;
    const file = (_a2 = e.target.files) == null ? void 0 : _a2[0];
    if (!file) return;
    try {
      const fileUrl = await chatService.uploadFile(chat.currentRoom.id, file, userId);
      await chat.sendMessage(file.name, file.type.startsWith("image/") ? "image" : "file");
    } catch (error) {
      console.error("Failed to upload file:", error);
    }
  };
  const formatTime = (date) => {
    return date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
  };
  const formatDate = (date) => {
    const today = /* @__PURE__ */ new Date();
    const messageDate = new Date(date);
    if (messageDate.toDateString() === today.toDateString()) {
      return "Today";
    }
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    if (messageDate.toDateString() === yesterday.toDateString()) {
      return "Yesterday";
    }
    return messageDate.toLocaleDateString();
  };
  const renderMessage = (message, index) => {
    var _a2, _b, _c;
    const isOwnMessage = message.senderId === userId;
    const prevMessage = index > 0 ? chat.messages[index - 1] : null;
    const showDateSeparator = !prevMessage || formatDate(message.timestamp) !== formatDate(prevMessage.timestamp);
    return (0, import_jsx_runtime9.jsxs)("div", { children: [
      showDateSeparator && (0, import_jsx_runtime9.jsx)("div", { className: "flex items-center justify-center my-4", children: (0, import_jsx_runtime9.jsx)("div", { className: "bg-gray-200 text-gray-600 px-3 py-1 rounded-full text-sm", children: formatDate(message.timestamp) }) }),
      (0, import_jsx_runtime9.jsxs)("div", { className: `flex mb-2 ${isOwnMessage ? "justify-end" : "justify-start"}`, children: [
        (0, import_jsx_runtime9.jsxs)("div", { className: `max-w-xs lg:max-w-md px-4 py-2 rounded-lg ${isOwnMessage ? "bg-blue-500 text-white" : "bg-gray-200 text-gray-900"}`, children: [
          !isOwnMessage && (0, import_jsx_runtime9.jsx)("div", { className: "text-xs font-semibold mb-1", children: message.senderName }),
          message.replyTo && (0, import_jsx_runtime9.jsxs)("div", { className: "text-xs opacity-75 mb-2 border-l-2 border-current pl-2", children: [
            "Replying to: ",
            (_a2 = chat.messages.find((m) => m.id === message.replyTo)) == null ? void 0 : _a2.content.slice(0, 50),
            "..."
          ] }),
          message.type === "image" && ((_b = message.metadata) == null ? void 0 : _b.imageUrl) && (0, import_jsx_runtime9.jsx)(
            "img",
            {
              src: message.metadata.imageUrl,
              alt: message.metadata.fileName,
              className: "max-w-full rounded mb-2"
            }
          ),
          message.type === "file" && ((_c = message.metadata) == null ? void 0 : _c.fileUrl) && (0, import_jsx_runtime9.jsxs)(
            "a",
            {
              href: message.metadata.fileUrl,
              target: "_blank",
              rel: "noopener noreferrer",
              className: "text-blue-300 underline",
              children: [
                "📎 ",
                message.metadata.fileName
              ]
            }
          ),
          (0, import_jsx_runtime9.jsx)("div", { className: "text-sm", children: message.content }),
          (0, import_jsx_runtime9.jsxs)("div", { className: `text-xs mt-1 ${isOwnMessage ? "text-blue-200" : "text-gray-500"}`, children: [
            formatTime(message.timestamp),
            message.edited && " (edited)"
          ] })
        ] }),
        isOwnMessage && chat.permissions.canEditMessages && (0, import_jsx_runtime9.jsxs)("div", { className: "ml-2", children: [
          (0, import_jsx_runtime9.jsx)(
            "button",
            {
              onClick: () => {
                setEditingMessage(message.id);
                setMessageInput(message.content);
              },
              className: "text-gray-400 hover:text-gray-600 p-1",
              children: (0, import_jsx_runtime9.jsx)(Pen, { size: 14 })
            }
          ),
          chat.permissions.canDeleteMessages && (0, import_jsx_runtime9.jsx)(
            "button",
            {
              onClick: () => chat.deleteMessage(message.id),
              className: "text-gray-400 hover:text-red-600 p-1",
              children: (0, import_jsx_runtime9.jsx)(Trash2, { size: 14 })
            }
          )
        ] }),
        !isOwnMessage && (0, import_jsx_runtime9.jsx)("div", { className: "ml-2", children: (0, import_jsx_runtime9.jsx)(
          "button",
          {
            onClick: () => setReplyingTo(message.id),
            className: "text-gray-400 hover:text-gray-600 p-1",
            children: (0, import_jsx_runtime9.jsx)(Reply, { size: 14 })
          }
        ) })
      ] })
    ] }, message.id);
  };
  if (!chat.currentRoom) {
    return (0, import_jsx_runtime9.jsx)("div", { className: `flex items-center justify-center h-full ${className}`, children: (0, import_jsx_runtime9.jsxs)("div", { className: "text-center", children: [
      (0, import_jsx_runtime9.jsx)(Users, { className: "mx-auto mb-4 text-gray-400", size: 48 }),
      (0, import_jsx_runtime9.jsx)("h3", { className: "text-lg font-semibold text-gray-900 mb-2", children: "No Chat Room Selected" }),
      (0, import_jsx_runtime9.jsx)("p", { className: "text-gray-600", children: "Select a room to start chatting" })
    ] }) });
  }
  return (0, import_jsx_runtime9.jsxs)("div", { className: `flex flex-col h-full bg-white ${className}`, children: [
    (0, import_jsx_runtime9.jsxs)("div", { className: "flex items-center justify-between p-4 border-b bg-gray-50", children: [
      (0, import_jsx_runtime9.jsxs)("div", { className: "flex items-center", children: [
        (0, import_jsx_runtime9.jsx)("div", { className: "w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center mr-3", children: (0, import_jsx_runtime9.jsx)(Users, { size: 16, className: "text-white" }) }),
        (0, import_jsx_runtime9.jsxs)("div", { children: [
          (0, import_jsx_runtime9.jsx)("h3", { className: "font-semibold text-gray-900", children: chat.currentRoom.name }),
          (0, import_jsx_runtime9.jsxs)("p", { className: "text-sm text-gray-600", children: [
            chat.participants.filter((p) => p.isOnline).length,
            " online"
          ] })
        ] })
      ] }),
      (0, import_jsx_runtime9.jsx)(
        "button",
        {
          onClick: () => setShowRoomSelector(!showRoomSelector),
          className: "text-gray-400 hover:text-gray-600",
          children: (0, import_jsx_runtime9.jsx)(EllipsisVertical, { size: 20 })
        }
      )
    ] }),
    (0, import_jsx_runtime9.jsxs)("div", { className: "flex-1 overflow-y-auto p-4", children: [
      chat.messages.map((message, index) => renderMessage(message, index)),
      (0, import_jsx_runtime9.jsx)("div", { ref: messagesEndRef })
    ] }),
    replyingTo && (0, import_jsx_runtime9.jsxs)("div", { className: "px-4 py-2 bg-gray-100 border-t flex items-center justify-between", children: [
      (0, import_jsx_runtime9.jsxs)("div", { className: "flex items-center", children: [
        (0, import_jsx_runtime9.jsx)(Reply, { size: 16, className: "text-gray-500 mr-2" }),
        (0, import_jsx_runtime9.jsxs)("span", { className: "text-sm text-gray-600", children: [
          "Replying to: ",
          (_a = chat.messages.find((m) => m.id === replyingTo)) == null ? void 0 : _a.content.slice(0, 50),
          "..."
        ] })
      ] }),
      (0, import_jsx_runtime9.jsx)(
        "button",
        {
          onClick: () => setReplyingTo(null),
          className: "text-gray-400 hover:text-gray-600",
          children: "✕"
        }
      )
    ] }),
    (0, import_jsx_runtime9.jsx)("form", { onSubmit: handleSendMessage, className: "p-4 border-t bg-gray-50", children: (0, import_jsx_runtime9.jsxs)("div", { className: "flex items-center space-x-2", children: [
      (0, import_jsx_runtime9.jsx)(
        "input",
        {
          type: "file",
          ref: fileInputRef,
          onChange: handleFileUpload,
          className: "hidden",
          accept: "image/*,.pdf,.doc,.docx,.txt"
        }
      ),
      (0, import_jsx_runtime9.jsx)(
        "button",
        {
          type: "button",
          onClick: () => {
            var _a2;
            return (_a2 = fileInputRef.current) == null ? void 0 : _a2.click();
          },
          className: "text-gray-400 hover:text-gray-600 p-2",
          disabled: !chat.permissions.canSendMessages,
          children: (0, import_jsx_runtime9.jsx)(Paperclip, { size: 20 })
        }
      ),
      (0, import_jsx_runtime9.jsx)(
        "input",
        {
          type: "text",
          value: messageInput,
          onChange: (e) => setMessageInput(e.target.value),
          placeholder: editingMessage ? "Edit message..." : "Type a message...",
          className: "flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500",
          disabled: !chat.permissions.canSendMessages
        }
      ),
      (0, import_jsx_runtime9.jsx)(
        "button",
        {
          type: "submit",
          disabled: !messageInput.trim() || !chat.permissions.canSendMessages,
          className: "bg-blue-500 text-white p-2 rounded-lg hover:bg-blue-600 disabled:bg-gray-300 disabled:cursor-not-allowed",
          children: (0, import_jsx_runtime9.jsx)(Send, { size: 20 })
        }
      )
    ] }) }),
    chat.error && (0, import_jsx_runtime9.jsx)("div", { className: "px-4 py-2 bg-red-100 border-t border-red-200", children: (0, import_jsx_runtime9.jsx)("p", { className: "text-red-700 text-sm", children: chat.error }) })
  ] });
};

// shared/api/auth.js
var me = async () => {
  const user = auth.currentUser;
  if (user) {
    return {
      id: user.uid,
      email: user.email,
      displayName: user.displayName
      // Add other user properties as needed
    };
  }
  return null;
};
var isAuthenticated = () => {
  return !!auth.currentUser;
};

// shared/api/client.js
var BASE_URL = "https://deprecated-api.example.com";
var API_KEY = "deprecated";
var MAX_RETRIES = 3;
var RETRY_DELAY = 1e3;
var ApiError = class extends Error {
  constructor(message, status, data) {
    super(message);
    this.status = status;
    this.data = data;
    this.name = "ApiError";
  }
};
var delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var shouldRetry = (error, attempt) => {
  if (attempt >= MAX_RETRIES) return false;
  if (!error.status) return true;
  return error.status >= 500;
};
var makeRequest = async (url, options = {}, attempt = 1) => {
  try {
    const response = await fetch(url, {
      ...options,
      headers: {
        "api_key": API_KEY,
        "Content-Type": "application/json",
        ...options.headers
      }
    });
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new ApiError(
        `HTTP ${response.status}: ${response.statusText}`,
        response.status,
        errorData
      );
    }
    return await response.json();
  } catch (error) {
    if (shouldRetry(error, attempt)) {
      await delay(RETRY_DELAY * attempt);
      return makeRequest(url, options, attempt + 1);
    }
    throw error;
  }
};
var apiClient = {
  get: (endpoint, params = {}) => {
    const url = new URL(`${BASE_URL}${endpoint}`);
    Object.keys(params).forEach((key) => {
      if (params[key] !== void 0 && params[key] !== null) {
        url.searchParams.append(key, params[key]);
      }
    });
    return makeRequest(url.toString());
  },
  put: (endpoint, data) => {
    return makeRequest(`${BASE_URL}${endpoint}`, {
      method: "PUT",
      body: JSON.stringify(data)
    });
  },
  post: (endpoint, data) => {
    return makeRequest(`${BASE_URL}${endpoint}`, {
      method: "POST",
      body: JSON.stringify(data)
    });
  },
  delete: (endpoint) => {
    return makeRequest(`${BASE_URL}${endpoint}`, {
      method: "DELETE"
    });
  }
};

// shared/api/entities/Player.js
var list = (options = {}) => {
  const { sort = "-stars", limit: limit2 = null } = options;
  return firebaseClient.entities.Player.list(sort, limit2);
};
var fetchPlayers = () => {
  return list();
};
var filter2 = (filters = {}, limit2 = null) => firebaseClient.entities.Player.filter(filters, limit2);
var create = (data) => firebaseClient.entities.Player.create(data);
var update2 = (id, data) => firebaseClient.entities.Player.update(id, data);
var remove = (id) => firebaseClient.entities.Player.delete(id);

// shared/api/entities.js
var createEntityOperations = (entityName) => {
  return {
    list: (orderBy2 = "-created_date", limit2 = null) => {
      var _a;
      return (_a = firebaseClient.entities[entityName]) == null ? void 0 : _a.list(orderBy2, limit2);
    },
    filter: (filters = {}, limit2 = null) => {
      var _a;
      return (_a = firebaseClient.entities[entityName]) == null ? void 0 : _a.filter(filters, limit2);
    },
    get: (id) => {
      var _a;
      return (_a = firebaseClient.entities[entityName]) == null ? void 0 : _a.get(id);
    },
    create: (data) => {
      var _a;
      return (_a = firebaseClient.entities[entityName]) == null ? void 0 : _a.create(data);
    },
    update: (id, data) => {
      var _a;
      return (_a = firebaseClient.entities[entityName]) == null ? void 0 : _a.update(id, data);
    },
    delete: (id) => {
      var _a;
      return (_a = firebaseClient.entities[entityName]) == null ? void 0 : _a.delete(id);
    },
    bulkCreate: (items) => {
      var _a;
      return (_a = firebaseClient.entities[entityName]) == null ? void 0 : _a.bulkCreate(items);
    }
  };
};
var Player = {
  ...createEntityOperations("Player"),
  list,
  filter: filter2,
  create,
  update: update2,
  delete: remove,
  fetchPlayers
};
var School = createEntityOperations("School");
var Contact = createEntityOperations("Contact");
var TeamHistory = createEntityOperations("TeamHistory");
var Tournament = createEntityOperations("Tournament");
var TournamentParticipation = createEntityOperations("TournamentParticipation");
var PlayerImage = createEntityOperations("PlayerImage");
var Team = createEntityOperations("Team");
var Coach = createEntityOperations("Coach");
var CoachAssignment = createEntityOperations("CoachAssignment");
var ParentPlayerAssignment = createEntityOperations("ParentPlayerAssignment");
var Payment = createEntityOperations("Payment");
var AdditionalFee = createEntityOperations("AdditionalFee");
var PaymentMethod = createEntityOperations("PaymentMethod");
var TeamFee = createEntityOperations("TeamFee");
var RecruitingInterest = createEntityOperations("RecruitingInterest");
var User2 = {
  me: async () => {
    const { auth: auth2 } = await import("./firebase-GI4ITY2R.js");
    const user = auth2.currentUser;
    if (user) {
      return {
        id: user.uid,
        email: user.email,
        displayName: user.displayName
        // Add other user properties as needed
      };
    }
    return null;
  },
  isAuthenticated: async () => {
    const { auth: auth2 } = await import("./firebase-GI4ITY2R.js");
    return !!auth2.currentUser;
  }
};

// shared/utils/tokenValidation.js
function sanitizeTokenForLogging(token, service = "unknown") {
  if (!token || typeof token !== "string") {
    return "[INVALID_TOKEN]";
  }
  const trimmed = token.trim();
  if (!trimmed) {
    return "[EMPTY_TOKEN]";
  }
  if (trimmed.length > 10) {
    const prefix = trimmed.substring(0, 3);
    const suffix = trimmed.substring(trimmed.length - 3);
    return `${prefix}***[${service.toUpperCase()}_TOKEN_REDACTED]***${suffix}`;
  }
  return `[${service.toUpperCase()}_TOKEN_REDACTED]`;
}
function sanitizeErrorMessage(message) {
  if (!message || typeof message !== "string") {
    return message;
  }
  let sanitized = message.replace(/hf_[a-zA-Z0-9]{34}/g, "[HF_TOKEN_REDACTED]");
  sanitized = sanitized.replace(/xkeysib-[a-f0-9]{64}-[a-zA-Z0-9]{16}/g, "[BREVO_TOKEN_REDACTED]");
  sanitized = sanitized.replace(/\b[a-zA-Z0-9]{32,}\b/g, "[POTENTIAL_TOKEN_REDACTED]");
  sanitized = sanitized.replace(/Bearer\s+[a-zA-Z0-9._-]+/gi, "Bearer [TOKEN_REDACTED]");
  sanitized = sanitized.replace(/Authorization:\s*[^\s,]+/gi, "Authorization: [TOKEN_REDACTED]");
  return sanitized;
}
function isTokenExpired(errorMessage) {
  if (!errorMessage || typeof errorMessage !== "string") {
    return false;
  }
  const expiredPatterns = [
    /token.*expired/i,
    /expired.*token/i,
    /token.*invalid/i,
    /invalid.*token/i,
    /unauthorized/i,
    /authentication.*failed/i,
    /access.*denied/i,
    /forbidden/i,
    /401/,
    /403/
  ];
  return expiredPatterns.some((pattern) => pattern.test(errorMessage));
}

// shared/utils/secureLogger.js
var LOG_LEVELS = {
  ERROR: "ERROR",
  WARN: "WARN",
  INFO: "INFO",
  DEBUG: "DEBUG"
};
var SENSITIVE_PATTERNS = [
  // API Keys and tokens
  { pattern: /hf_[a-zA-Z0-9]{34}/g, replacement: "[HF_TOKEN_REDACTED]" },
  { pattern: /xkeysib-[a-f0-9]{64}-[a-zA-Z0-9]{16}/g, replacement: "[BREVO_TOKEN_REDACTED]" },
  { pattern: /Bearer\s+[a-zA-Z0-9._-]+/gi, replacement: "Bearer [TOKEN_REDACTED]" },
  { pattern: /Authorization:\s*[^\s,]+/gi, replacement: "Authorization: [TOKEN_REDACTED]" },
  // Email addresses
  { pattern: /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, replacement: "[EMAIL_REDACTED]" },
  // Phone numbers (US format)
  { pattern: /\b\d{3}-\d{3}-\d{4}\b/g, replacement: "[PHONE_REDACTED]" },
  { pattern: /\b\(\d{3}\)\s*\d{3}-\d{4}\b/g, replacement: "[PHONE_REDACTED]" },
  // Credit card numbers (basic pattern)
  { pattern: /\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b/g, replacement: "[CARD_REDACTED]" },
  // Social Security Numbers
  { pattern: /\b\d{3}-\d{2}-\d{4}\b/g, replacement: "[SSN_REDACTED]" },
  // IP Addresses (optional - might be needed for debugging)
  // { pattern: /\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b/g, replacement: '[IP_REDACTED]' },
  // Passwords in URLs or form data
  { pattern: /password[=:]\s*[^\s&]+/gi, replacement: "password=[PASSWORD_REDACTED]" },
  { pattern: /pwd[=:]\s*[^\s&]+/gi, replacement: "pwd=[PASSWORD_REDACTED]" },
  // Generic long alphanumeric strings that might be tokens (32+ chars)
  { pattern: /\b[a-zA-Z0-9]{32,}\b/g, replacement: "[POTENTIAL_TOKEN_REDACTED]" }
];
function sanitizeMessage(message) {
  if (typeof message === "string") {
    let sanitized = message;
    for (const { pattern, replacement } of SENSITIVE_PATTERNS) {
      sanitized = sanitized.replace(pattern, replacement);
    }
    return sanitized;
  }
  if (typeof message === "object" && message !== null) {
    if (Array.isArray(message)) {
      return message.map((item) => sanitizeMessage(item));
    }
    const sanitized = {};
    for (const [key, value] of Object.entries(message)) {
      const sanitizedKey = sanitizeMessage(key);
      const sanitizedValue = sanitizeMessage(value);
      sanitized[sanitizedKey] = sanitizedValue;
    }
    return sanitized;
  }
  return message;
}
function createLogEntry(level, component, message, metadata = {}) {
  return {
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    level,
    component,
    message: sanitizeMessage(message),
    metadata: sanitizeMessage(metadata),
    environment: "development"
  };
}
var SecureLogger = class {
  constructor(component) {
    this.component = component;
  }
  /**
   * Logs an error message with automatic sanitization
   * @param {string} message - Error message
   * @param {Object} metadata - Additional error metadata
   */
  error(message, metadata = {}) {
    const logEntry = createLogEntry(LOG_LEVELS.ERROR, this.component, message, metadata);
    console.error(`[${logEntry.component}] ERROR:`, logEntry.message, logEntry.metadata);
  }
  /**
   * Logs a warning message with automatic sanitization
   * @param {string} message - Warning message
   * @param {Object} metadata - Additional warning metadata
   */
  warn(message, metadata = {}) {
    const logEntry = createLogEntry(LOG_LEVELS.WARN, this.component, message, metadata);
    console.warn(`[${logEntry.component}] WARN:`, logEntry.message, logEntry.metadata);
  }
  /**
   * Logs an info message with automatic sanitization
   * @param {string} message - Info message
   * @param {Object} metadata - Additional info metadata
   */
  info(message, metadata = {}) {
    const logEntry = createLogEntry(LOG_LEVELS.INFO, this.component, message, metadata);
    console.log(`[${logEntry.component}] INFO:`, logEntry.message, logEntry.metadata);
  }
  /**
   * Logs a debug message with automatic sanitization (only in development)
   * @param {string} message - Debug message
   * @param {Object} metadata - Additional debug metadata
   */
  debug(message, metadata = {}) {
    if (true) {
      const logEntry = createLogEntry(LOG_LEVELS.DEBUG, this.component, message, metadata);
      console.debug(`[${logEntry.component}] DEBUG:`, logEntry.message, logEntry.metadata);
    }
  }
  /**
   * Logs authentication-related events with enhanced security
   * @param {string} event - Authentication event type
   * @param {Object} details - Event details (will be sanitized)
   */
  authEvent(event, details = {}) {
    const sanitizedDetails = {
      ...sanitizeMessage(details),
      // Ensure tokens are properly sanitized
      token: details.token ? sanitizeTokenForLogging(details.token, details.service || "unknown") : void 0
    };
    this.info(`Authentication event: ${event}`, sanitizedDetails);
  }
  /**
   * Logs API request/response with automatic sanitization
   * @param {string} method - HTTP method
   * @param {string} url - Request URL
   * @param {number} status - Response status
   * @param {Object} metadata - Additional request metadata
   */
  apiCall(method, url, status, metadata = {}) {
    const sanitizedUrl = sanitizeMessage(url);
    const sanitizedMetadata = sanitizeMessage(metadata);
    const logLevel = status >= 400 ? LOG_LEVELS.ERROR : LOG_LEVELS.INFO;
    const message = `${method} ${sanitizedUrl} - ${status}`;
    if (logLevel === LOG_LEVELS.ERROR) {
      this.error(message, sanitizedMetadata);
    } else {
      this.info(message, sanitizedMetadata);
    }
  }
  /**
   * Logs performance metrics
   * @param {string} operation - Operation name
   * @param {number} duration - Duration in milliseconds
   * @param {Object} metadata - Additional performance metadata
   */
  performance(operation, duration, metadata = {}) {
    this.info(`Performance: ${operation} completed in ${duration}ms`, sanitizeMessage(metadata));
  }
  /**
   * Logs security events with enhanced detail
   * @param {string} event - Security event type
   * @param {Object} details - Event details
   */
  security(event, details = {}) {
    const sanitizedDetails = sanitizeMessage(details);
    this.warn(`Security event: ${event}`, sanitizedDetails);
  }
};
function createSecureLogger(component) {
  return new SecureLogger(component);
}

// shared/api/integrations/documentationService.js
var logger = createSecureLogger("Documentation Service");
var DocumentationService = class {
  constructor() {
    this.baseURL = "/api/documentation";
  }
  /**
   * Ask a question about the O7C Hub documentation
   * @param {string} question - The question to ask
   * @param {string} [additionalContext] - Additional context to include
   * @returns {Promise<Object>} Response with answer and metadata
   */
  async askQuestion(question, additionalContext = "") {
    var _a, _b, _c;
    try {
      logger.debug("Sending documentation question", {
        questionLength: question.length,
        hasAdditionalContext: !!additionalContext
      });
      const response = await fetch(this.baseURL, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          question,
          context: additionalContext
        })
      });
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: "Unknown error" }));
        logger.error("Documentation API request failed", {
          status: response.status,
          error: sanitizeErrorMessage(errorData.error || "Unknown error"),
          errorCode: errorData.errorCode
        });
        throw new Error(errorData.error || `HTTP ${response.status}`);
      }
      const data = await response.json();
      logger.info("Documentation question answered successfully", {
        responseLength: ((_a = data.answer) == null ? void 0 : _a.length) || 0,
        relevantSectionsCount: ((_c = (_b = data.metadata) == null ? void 0 : _b.relevantSections) == null ? void 0 : _c.length) || 0
      });
      return {
        success: true,
        answer: data.answer,
        metadata: data.metadata,
        model: data.model,
        generatedAt: data.generatedAt
      };
    } catch (error) {
      logger.error("Error asking documentation question", {
        error: sanitizeErrorMessage(error.message),
        question: question.substring(0, 100)
      });
      return {
        success: false,
        error: error.message,
        answer: null,
        metadata: null
      };
    }
  }
  /**
   * Get documentation statistics
   * @returns {Promise<Object>} Documentation knowledge base statistics
   */
  async getDocumentationStats() {
    try {
      return {
        success: true,
        stats: {
          lastUpdated: (/* @__PURE__ */ new Date()).toISOString(),
          status: "available"
        }
      };
    } catch (error) {
      logger.error("Error getting documentation stats", {
        error: sanitizeErrorMessage(error.message)
      });
      return {
        success: false,
        error: error.message,
        stats: null
      };
    }
  }
  /**
   * Check if documentation service is available
   * @returns {Promise<boolean>} True if service is available
   */
  async isServiceAvailable() {
    try {
      const response = await fetch(this.baseURL, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          question: "test availability"
        })
      });
      return response.ok;
    } catch (error) {
      logger.debug("Documentation service availability check failed", {
        error: sanitizeErrorMessage(error.message)
      });
      return false;
    }
  }
};
var documentationService = new DocumentationService();

// shared/api/integrations/aiService.js
var logger2 = createSecureLogger("AI Service");
var AIServiceError = class extends Error {
  constructor(message, errorCode, userMessage, troubleshooting) {
    super(message);
    this.name = "AIServiceError";
    this.errorCode = errorCode;
    this.userMessage = userMessage;
    this.troubleshooting = troubleshooting;
  }
};
function getFallbackResponse(query2, model) {
  let fallbackMessage = "AI features are currently unavailable, but you can still use all other features of the application.";
  let fallbackSteps = [
    "Try again later when the AI service is restored",
    "Contact your administrator if this issue persists",
    "All other application features remain fully functional"
  ];
  if (query2 && typeof query2 === "string") {
    if (query2.toLowerCase().includes("player") || query2.toLowerCase().includes("recruit")) {
      fallbackMessage = "AI-powered player analysis is temporarily unavailable. You can still view player profiles, stats, and manage recruiting manually.";
      fallbackSteps = [
        "Use the player search and filtering features",
        "View player profiles and statistics manually",
        "Try the AI features again later",
        "Contact support if AI features remain unavailable"
      ];
    } else if (query2.toLowerCase().includes("team") || query2.toLowerCase().includes("roster")) {
      fallbackMessage = "AI-powered team analysis is temporarily unavailable. You can still manage teams and rosters using the standard interface.";
      fallbackSteps = [
        "Use the team management interface",
        "Access roster information directly",
        "Try the AI features again later",
        "Contact support if AI features remain unavailable"
      ];
    }
  }
  return {
    success: false,
    error: "AI service unavailable",
    errorCode: "SERVICE_UNAVAILABLE",
    userMessage: fallbackMessage,
    troubleshooting: {
      steps: fallbackSteps,
      note: "This is a graceful fallback - the application continues to work normally without AI features."
    },
    response: null,
    model,
    tokens: { prompt: 0, completion: 0, total: 0 },
    generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
    fallback: true
  };
}
function getUserQuery(params) {
  if (params.messages && params.messages.length > 0) {
    const lastMessage = params.messages[params.messages.length - 1];
    if (lastMessage.role === "user") {
      return lastMessage.content;
    }
  }
  return params.prompt || "";
}
function buildO7CHubSystemPrompt() {
  return `You are an expert AI assistant for the O7C Hub application, a comprehensive recruiting and athlete management platform for Ohio baseball.

## Your Expertise Areas:

### 1. PLAYER MANAGEMENT
- Player profiles, statistics, and performance tracking
- Academic information and GPA monitoring
- Contact details and communication preferences
- Medical history and injury tracking
- Equipment and uniform assignments

### 2. RECRUITING SYSTEM
- College recruiting process and timelines
- NCAA compliance and eligibility rules
- Scholarship offers and commitment tracking
- Coach communications and evaluations
- Recruiting calendars and deadlines

### 3. TEAM MANAGEMENT
- Roster management and player assignments
- Team scheduling and practice planning
- Tournament registrations and travel coordination
- Fee collection and financial tracking
- Parent communications and updates

### 4. ANALYTICS & INSIGHTS
- Performance analytics and trend analysis
- Statistical comparisons and benchmarks
- Recruiting success metrics
- Team performance indicators
- Predictive modeling for player development

### 5. USER ROLES & PERMISSIONS
- Admin: Full system access and configuration
- Coach: Team management and player oversight
- Parent: Child's information and communications
- Player: Personal profile and recruiting status

## Your Capabilities:
- Access real-time player, team, and recruiting data
- Provide data-driven insights and recommendations
- Answer questions about platform features and functionality
- Assist with recruiting strategy and player development
- Help troubleshoot platform issues and guide users
- Generate reports and analytics summaries

## Communication Guidelines:
- Be professional, helpful, and encouraging
- Use clear, concise language appropriate for baseball recruiting
- Provide specific, actionable advice when possible
- Reference actual data points and statistics when available
- Acknowledge limitations when data isn't available
- Focus on baseball recruiting excellence and athlete development

## Data Access:
You have access to comprehensive player databases, recruiting histories, team information, and platform documentation. Use this context to provide informed, accurate responses about the O7C Hub ecosystem.`;
}
function buildConversationContext(messages) {
  if (!messages || messages.length <= 1) return "";
  const recentMessages = messages.slice(-6);
  const contextParts = [];
  for (const message of recentMessages) {
    if (message.role === "user") {
      contextParts.push(`User: ${message.content}`);
    } else if (message.role === "assistant") {
      contextParts.push(`Assistant: ${message.content}`);
    }
  }
  return `Recent Conversation:
${contextParts.join("\n")}
`;
}
async function fetchRelevantData(query2, userContext = {}) {
  const data = [];
  const seenIds = /* @__PURE__ */ new Set();
  try {
    const queryLower = query2.toLowerCase();
    const isPlayerQuery = /\b(player|players|athlete|student)\b/i.test(queryLower);
    const isTeamQuery = /\b(team|roster|squad)\b/i.test(queryLower);
    const isRecruitingQuery = /\b(recruit|recruiting|college|scholarship|commit)\b/i.test(queryLower);
    const isAnalyticsQuery = /\b(stat|performance|analytics|trend|average|gpa)\b/i.test(queryLower);
    const words = query2.split(/\s+/).filter(
      (word) => word.length > 1 && /[A-Z]/.test(word) && !["The", "And", "Or", "But", "In", "On", "At", "To", "For", "Of", "With", "By"].includes(word)
    );
    const searchPatterns = [
      // Direct name searches
      ...words.slice(0, 3),
      // Extract potential school names (words with multiple capitals)
      ...query2.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)+\b/g) || [],
      // Extract years/class references
      ...query2.match(/\b(20\d{2}|class\s+of\s+\d{4})\b/gi) || []
    ];
    for (const pattern of searchPatterns.slice(0, 5)) {
      try {
        if (isPlayerQuery || words.length > 0) {
          const playerSearches = [
            { fullname: pattern },
            { firstName: pattern },
            { lastName: pattern },
            { emailAddress: pattern },
            { commitment: pattern }
          ];
          for (const search of playerSearches) {
            const players = await Player.filter(search, 2);
            if (players && players.length > 0) {
              for (const player of players) {
                if (!seenIds.has(`player-${player.id}`)) {
                  data.push({
                    type: "player",
                    data: {
                      id: player.id,
                      name: `${player.firstName} ${player.lastName}`,
                      position: player.position,
                      grade: player.grade,
                      commitment: player.commitment,
                      gpa: player.gpa,
                      contact: player.emailAddress,
                      phone: player.phoneNumber,
                      stats: player.stats || {}
                    }
                  });
                  seenIds.add(`player-${player.id}`);
                }
              }
            }
          }
        }
        const schoolSearches = [
          { name: pattern },
          { city: pattern },
          { state: pattern }
        ];
        for (const search of schoolSearches) {
          const schools = await School.filter(search, 2);
          if (schools && schools.length > 0) {
            for (const school of schools) {
              if (!seenIds.has(`school-${school.id}`)) {
                data.push({
                  type: "school",
                  data: {
                    id: school.id,
                    name: school.name,
                    city: school.city,
                    state: school.state,
                    type: school.type
                  }
                });
                seenIds.add(`school-${school.id}`);
              }
            }
          }
        }
        if (isTeamQuery || isRecruitingQuery) {
          const coachSearches = [
            { firstName: pattern },
            { lastName: pattern },
            { email: pattern }
          ];
          for (const search of coachSearches) {
            const coaches = await Coach.filter(search, 2);
            if (coaches && coaches.length > 0) {
              for (const coach of coaches) {
                if (!seenIds.has(`coach-${coach.id}`)) {
                  data.push({
                    type: "coach",
                    data: {
                      id: coach.id,
                      name: `${coach.firstName} ${coach.lastName}`,
                      email: coach.email,
                      phone: coach.phoneNumber,
                      team: coach.teamName
                    }
                  });
                  seenIds.add(`coach-${coach.id}`);
                }
              }
            }
          }
        }
      } catch (e) {
        logger2.debug("Error fetching data for pattern", {
          pattern,
          error: sanitizeErrorMessage(e.message || "Unknown error"),
          errorName: e.name
        });
      }
    }
    if (isAnalyticsQuery) {
      try {
        const totalPlayers = await Player.list(void 0, 1);
        data.push({
          type: "analytics_context",
          data: {
            totalPlayers: (totalPlayers == null ? void 0 : totalPlayers.length) || 0,
            queryType: "analytics"
          }
        });
      } catch (e) {
        logger2.debug("Error fetching analytics context", {
          error: sanitizeErrorMessage(e.message || "Unknown error")
        });
      }
    }
    if (isRecruitingQuery) {
      try {
        data.push({
          type: "recruiting_context",
          data: {
            currentSeason: (/* @__PURE__ */ new Date()).getFullYear(),
            recruitingPeriods: ["Fall", "Winter", "Spring", "Summer"],
            queryType: "recruiting"
          }
        });
      } catch (e) {
        logger2.debug("Error fetching recruiting context", {
          error: sanitizeErrorMessage(e.message || "Unknown error")
        });
      }
    }
  } catch (e) {
    logger2.debug("Error in enhanced data fetching", {
      error: sanitizeErrorMessage(e.message || "Unknown error"),
      errorName: e.name
    });
  }
  if (data.length === 0) return "";
  const limitedData = data.slice(0, 12);
  return "\nRelevant Application Data:\n" + limitedData.map((item) => {
    const { type, data: itemData } = item;
    return `[${type.toUpperCase()}]
${JSON.stringify(itemData, null, 2)}`;
  }).join("\n\n");
}
async function invokeLLM(params) {
  var _a, _b, _c, _d, _e, _f, _g;
  const model = params.model || "google/flan-t5-large";
  const endpoint = "/api/huggingface";
  const gracefulFallback = params.gracefulFallback !== false;
  let messages;
  if (params.messages && Array.isArray(params.messages)) {
    messages = params.messages;
  } else if (params.prompt) {
    messages = [{ role: "user", content: params.prompt }];
  } else {
    throw new Error("Either prompt or messages must be provided");
  }
  let dataContext = params.dataContext || "";
  const userQuery = getUserQuery(params);
  if (userQuery) {
    try {
      const fetchedData = await fetchRelevantData(userQuery);
      if (fetchedData) {
        dataContext += fetchedData;
      }
      const docKeywords = ["how", "what", "guide", "help", "documentation", "manual", "tutorial", "feature", "function", "api", "endpoint", "error", "troubleshoot", "problem", "issue"];
      const isDocumentationQuery = docKeywords.some(
        (keyword) => userQuery.toLowerCase().includes(keyword)
      );
      if (isDocumentationQuery) {
        try {
          logger2.debug("Detected documentation query, fetching relevant documentation context", {
            query: userQuery.substring(0, 100)
          });
          const docResponse = await documentationService.askQuestion(userQuery);
          if (docResponse.success && docResponse.answer) {
            dataContext += `

Documentation Context:
${docResponse.answer}`;
            if (((_b = (_a = docResponse.metadata) == null ? void 0 : _a.relevantSections) == null ? void 0 : _b.length) > 0) {
              dataContext += `

Relevant Documentation Sections:
${docResponse.metadata.relevantSections.map((s) => `- ${s.title} (${s.path})`).join("\n")}`;
            }
          }
        } catch (docError) {
          logger2.debug("Error fetching documentation context", {
            error: sanitizeErrorMessage(docError.message || "Unknown error")
          });
        }
      }
    } catch (e) {
      logger2.debug("Error fetching relevant data for query", {
        queryLength: (userQuery == null ? void 0 : userQuery.length) || 0,
        error: sanitizeErrorMessage(e.message || "Unknown error"),
        errorName: e.name
      });
    }
  }
  const systemPrompt = params.systemPrompt || buildO7CHubSystemPrompt();
  const conversationContext = buildConversationContext(messages);
  let prompt = `${systemPrompt}

${conversationContext}`;
  if (dataContext) {
    prompt += `

Relevant Application Data:
${dataContext}`;
  }
  const lastUserMessage = messages.filter((m) => m.role === "user").pop();
  if (lastUserMessage) {
    prompt += `

User Question: ${lastUserMessage.content}`;
  } else {
    prompt += `

User Question: ${params.prompt || ""}`;
  }
  const requestBody = {
    model: "google/flan-t5-large",
    // Upgrade to larger model for better understanding
    inputs: prompt,
    options: {
      wait_for_model: true,
      use_cache: false,
      max_new_tokens: 512,
      temperature: 0.3,
      do_sample: true,
      repetition_penalty: 1.1,
      length_penalty: 1
    }
  };
  try {
    logger2.debug("Making LLM request", {
      model,
      endpoint,
      promptLength: prompt.length,
      hasDataContext: !!dataContext,
      gracefulFallback
    });
    const startTime = Date.now();
    const response = await fetch(endpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(requestBody)
    });
    const duration = Date.now() - startTime;
    logger2.performance("LLM API call", duration, {
      model,
      status: response.status,
      promptLength: prompt.length
    });
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({
        error: "Unknown error",
        errorCode: "UNKNOWN_ERROR",
        message: "An unexpected error occurred"
      }));
      const errorCode = errorData.errorCode || "UNKNOWN_ERROR";
      const userMessage = errorData.message || "An unexpected error occurred";
      const troubleshooting = errorData.troubleshooting || { steps: [] };
      if (response.status === 401) {
        const authErrorMessage = errorData.message || "The AI service authentication has failed. This usually means the API token is invalid, expired, or missing.";
        const authTroubleshooting = errorData.troubleshooting || {
          steps: [
            "Contact your system administrator to verify the API token configuration",
            "The HuggingFace API token may need to be renewed",
            "Check that the token has proper permissions for the inference API"
          ],
          documentation: "https://huggingface.co/docs/api-inference/quicktour"
        };
        throw new AIServiceError(
          "Authentication failed with AI service",
          errorCode,
          authErrorMessage,
          authTroubleshooting
        );
      }
      if (response.status === 429) {
        const rateLimitMessage = errorData.message || "The AI service is currently experiencing high demand. Please wait before trying again.";
        const rateLimitTroubleshooting = errorData.troubleshooting || {
          steps: [
            "Wait a few minutes before making another request",
            "Try with shorter input text to reduce processing time",
            "The service may be experiencing high demand"
          ]
        };
        throw new AIServiceError(
          "Rate limit exceeded",
          errorCode,
          rateLimitMessage,
          rateLimitTroubleshooting
        );
      }
      if (response.status === 503) {
        const loadingMessage = errorData.message || "The AI model is currently loading. This is normal for the first request and should resolve shortly.";
        const loadingTroubleshooting = errorData.troubleshooting || {
          steps: [
            "Wait 10-30 seconds and try again",
            "The model needs time to initialize on first use",
            "Subsequent requests should be faster"
          ]
        };
        throw new AIServiceError(
          "AI model is loading",
          errorCode,
          loadingMessage,
          loadingTroubleshooting
        );
      }
      if (response.status === 400) {
        const badRequestMessage = errorData.message || "Your input could not be processed by the AI service. Please check your input and try again.";
        const badRequestTroubleshooting = errorData.troubleshooting || {
          steps: [
            "Try with shorter or simpler text",
            "Remove any special characters that might cause issues",
            "Ensure your input is in a supported format"
          ]
        };
        throw new AIServiceError(
          "Invalid request to AI service",
          errorCode,
          badRequestMessage,
          badRequestTroubleshooting
        );
      }
      if (response.status === 500) {
        const serverErrorMessage = errorData.message || "The AI service is experiencing a configuration issue. Please contact your administrator.";
        const serverTroubleshooting = errorData.troubleshooting || {
          steps: [
            "Contact your system administrator",
            "The AI service may need to be reconfigured",
            "Try again later as this may be a temporary issue"
          ]
        };
        throw new AIServiceError(
          "AI service configuration error",
          errorCode,
          serverErrorMessage,
          serverTroubleshooting
        );
      }
      throw new AIServiceError(
        `AI service error: ${response.status}`,
        errorCode,
        userMessage,
        troubleshooting.steps.length > 0 ? troubleshooting : {
          steps: [
            "Try again in a few moments",
            "Check your internet connection",
            "Contact support if the issue persists"
          ]
        }
      );
    }
    const data = await response.json();
    let responseContent = "";
    if (Array.isArray(data) && ((_c = data[0]) == null ? void 0 : _c.generated_text)) {
      responseContent = data[0].generated_text.trim();
    } else if (data.generated_text) {
      responseContent = data.generated_text.trim();
    } else {
      throw new Error("Invalid response from Hugging Face API: no generated_text in response");
    }
    try {
      await runTransaction(db, async (transaction) => {
        const counterRef = doc(db, "counters", "aiUsage");
        const counterDoc = await transaction.get(counterRef);
        const newCount = (counterDoc.exists() ? counterDoc.data().count || 0 : 0) + 1;
        transaction.set(counterRef, { count: newCount }, { merge: true });
      });
    } catch (counterError) {
      logger2.warn("Error updating AI usage counter", {
        error: sanitizeErrorMessage(counterError.message || "Unknown error"),
        errorName: counterError.name
      });
    }
    logger2.info("LLM request completed successfully", {
      model,
      responseLength: responseContent.length,
      duration
    });
    return {
      success: true,
      response: responseContent,
      model,
      tokens: {
        prompt: 0,
        // HF free API doesn't provide token counts
        completion: 0,
        total: 0
      },
      generatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  } catch (error) {
    logger2.error("Error invoking LLM", {
      error: sanitizeErrorMessage(error.message || "Unknown error"),
      errorName: error.name,
      errorCode: error.errorCode || "UNKNOWN_ERROR",
      model,
      queryLength: ((_d = getUserQuery(params)) == null ? void 0 : _d.length) || 0,
      gracefulFallback
    });
    if (error instanceof AIServiceError) {
      logger2.error(`AI Service Error [${error.errorCode}]`, {
        message: sanitizeErrorMessage(error.message),
        userMessage: error.userMessage,
        troubleshooting: error.troubleshooting,
        isTokenExpired: isTokenExpired(error.message),
        model
      });
      if (gracefulFallback && (error.errorCode === "UNAUTHORIZED" || error.errorCode === "MISSING_TOKEN" || error.errorCode === "INVALID_TOKEN_FORMAT" || error.errorCode === "MODEL_LOADING" || error.errorCode === "RATE_LIMITED")) {
        logger2.info("Providing fallback response due to AI service unavailability", {
          errorCode: error.errorCode,
          model,
          queryLength: ((_e = getUserQuery(params)) == null ? void 0 : _e.length) || 0
        });
        return getFallbackResponse(getUserQuery(params), model);
      }
      return {
        success: false,
        error: error.message,
        errorCode: error.errorCode,
        userMessage: error.userMessage,
        troubleshooting: error.troubleshooting,
        response: null,
        model,
        tokens: { prompt: 0, completion: 0, total: 0 },
        generatedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
    }
    let errorCode = "UNKNOWN_ERROR";
    let userMessage = "An unexpected error occurred while processing your request.";
    let troubleshooting = {
      steps: [
        "Try again in a few moments",
        "Check your internet connection",
        "Contact support if the issue persists"
      ]
    };
    if (error.name === "TypeError" && (error.message.includes("fetch") || error.message.includes("Failed to fetch"))) {
      errorCode = "NETWORK_ERROR";
      userMessage = "Unable to connect to the AI service. This could be due to network connectivity issues or the service being temporarily unavailable.";
      troubleshooting = {
        steps: [
          "Check your internet connection",
          "Try refreshing the page",
          "Wait a few minutes and try again",
          "The AI service may be temporarily unavailable"
        ]
      };
      if (gracefulFallback) {
        logger2.info("Providing fallback response due to network error", {
          errorCode,
          model,
          queryLength: ((_f = getUserQuery(params)) == null ? void 0 : _f.length) || 0
        });
        return getFallbackResponse(getUserQuery(params), model);
      }
    } else if (error.name === "AbortError") {
      errorCode = "REQUEST_TIMEOUT";
      userMessage = "The AI service request took too long to complete. This may be due to high demand or network issues.";
      troubleshooting = {
        steps: [
          "Try again with shorter input text",
          "Check your internet connection speed",
          "Wait a few minutes as the service may be experiencing high load",
          "Break longer requests into smaller parts"
        ]
      };
      if (gracefulFallback) {
        logger2.info("Providing fallback response due to request timeout", {
          errorCode,
          model,
          queryLength: ((_g = getUserQuery(params)) == null ? void 0 : _g.length) || 0
        });
        return getFallbackResponse(getUserQuery(params), model);
      }
    } else if (error instanceof SyntaxError && error.message.includes("JSON")) {
      errorCode = "INVALID_RESPONSE";
      userMessage = "The AI service returned an invalid response. This is usually a temporary issue.";
      troubleshooting = {
        steps: [
          "Try again in a few moments",
          "The AI service may be experiencing temporary issues",
          "Contact support if this error persists"
        ]
      };
    } else {
      logger2.error("Unexpected error type", {
        name: error.name,
        error: sanitizeErrorMessage(error.message || "Unknown error"),
        errorCode,
        model
      });
      userMessage = "An unexpected error occurred while communicating with the AI service.";
      troubleshooting = {
        steps: [
          "Try again in a few moments",
          "Refresh the page and try again",
          "Check your internet connection",
          "Contact support if the issue persists"
        ]
      };
    }
    logger2.error(`Unhandled error [${errorCode}]`, {
      name: error.name,
      error: sanitizeErrorMessage(error.message || "Unknown error"),
      stack: error.stack ? sanitizeErrorMessage(error.stack) : "No stack trace",
      model,
      gracefulFallback
    });
    return {
      success: false,
      error: error.message,
      errorCode,
      userMessage,
      troubleshooting,
      response: null,
      model,
      tokens: { prompt: 0, completion: 0, total: 0 },
      generatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
}

// shared/api/integrations/emailService.js
async function sendEmail(params) {
  try {
    if (!params.to || !params.subject || !params.body) {
      throw new Error("Missing required email parameters: to, subject, body");
    }
    const payload = {
      sender: {
        email: params.from || "noreply@o7chub.com",
        name: params.from_name || "O7C Hub"
      },
      to: [
        {
          email: params.to
        }
      ],
      subject: params.subject,
      htmlContent: params.body,
      ...params.text && { textContent: params.text }
    };
    const response = await fetch("/api/brevo", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ endpoint: "/v3/smtp/email", payload })
    });
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(`Brevo API error: ${errorData.message || response.statusText}`);
    }
    const result = await response.json();
    return {
      success: true,
      messageId: result.messageId || `brevo_${Date.now()}`,
      to: params.to,
      subject: params.subject,
      sentAt: (/* @__PURE__ */ new Date()).toISOString(),
      status: "sent"
    };
  } catch (error) {
    console.error("Email send failed:", error);
    return {
      success: false,
      error: error.message,
      to: params.to,
      subject: params.subject,
      sentAt: (/* @__PURE__ */ new Date()).toISOString(),
      status: "failed"
    };
  }
}

// shared/api/integrations/fileUpload.js
async function uploadFile(params) {
  var _a;
  console.log("uploadFile called with params:", params);
  return {
    success: true,
    url: `https://mock-storage.example.com/files/${params.filename}`,
    id: `file_${Date.now()}`,
    filename: params.filename,
    size: ((_a = params.file) == null ? void 0 : _a.size) || 0,
    uploadedAt: (/* @__PURE__ */ new Date()).toISOString()
  };
}

// shared/api/integrations/imageGeneration.js
async function generateImage(params) {
  console.log("generateImage called with params:", params);
  return {
    success: true,
    images: [
      {
        url: `https://mock-image-generator.example.com/images/${Date.now()}.png`,
        prompt: params.prompt,
        size: params.size || "1024x1024",
        generatedAt: (/* @__PURE__ */ new Date()).toISOString()
      }
    ],
    usage: {
      images: params.n || 1
    }
  };
}

// shared/api/integrations.js
var Core = {
  InvokeLLM: invokeLLM,
  SendEmail: sendEmail,
  UploadFile: uploadFile,
  GenerateImage: generateImage,
  ExtractDataFromUploadedFile: async (params) => {
    console.log("ExtractDataFromUploadedFile called with params:", params);
    return {
      success: true,
      extractedData: {
        text: "Mock extracted text from file",
        metadata: params
      }
    };
  },
  CreateFileSignedUrl: async (params) => {
    console.log("CreateFileSignedUrl called with params:", params);
    return {
      success: true,
      signedUrl: `https://mock-signed-url.com/${params.fileName || "file"}`,
      expiresAt: new Date(Date.now() + 36e5).toISOString()
      // 1 hour from now
    };
  },
  UploadPrivateFile: async (params) => {
    console.log("UploadPrivateFile called with params:", params);
    return {
      success: true,
      fileId: `mock-file-id-${Date.now()}`,
      url: `https://mock-private-url.com/${params.fileName || "file"}`
    };
  }
};
var InvokeLLM = invokeLLM;
var SendEmail = sendEmail;
var UploadFile = uploadFile;
var GenerateImage = generateImage;
var ExtractDataFromUploadedFile = Core.ExtractDataFromUploadedFile;
var CreateFileSignedUrl = Core.CreateFileSignedUrl;
var UploadPrivateFile = Core.UploadPrivateFile;

// shared/services/authRedirect.ts
var AuthRedirectService = class _AuthRedirectService {
  constructor() {
  }
  static getInstance() {
    if (!_AuthRedirectService.instance) {
      _AuthRedirectService.instance = new _AuthRedirectService();
    }
    return _AuthRedirectService.instance;
  }
  /**
   * Redirect user to their appropriate app based on role
   */
  redirectByRole(userRole, options = {}) {
    if (!shouldRedirectUser(userRole)) {
      return;
    }
    const redirectUrl = getRedirectUrl(userRole);
    this.performRedirect(redirectUrl, options);
  }
  /**
   * Redirect to a specific app
   */
  redirectToApp(appKey, options = {}) {
    const currentApp = getCurrentApp();
    if (currentApp === appKey) {
      return;
    }
    const baseUrl = appKey === "o7c-hub" ? false ? "https://o7c-hub.vercel.app" : "http://localhost:3000" : false ? "https://player-portal.vercel.app" : "http://localhost:3001";
    this.performRedirect(baseUrl, options);
  }
  /**
   * Perform the actual redirect with options
   */
  performRedirect(url, options) {
    const { preserveQuery = true, preserveHash = true, delay: delay2 = 0 } = options;
    let finalUrl = url;
    if (preserveQuery && window.location.search) {
      const urlObj = new URL(url);
      const currentParams = new URLSearchParams(window.location.search);
      currentParams.forEach((value, key) => {
        if (!urlObj.searchParams.has(key)) {
          urlObj.searchParams.set(key, value);
        }
      });
      finalUrl = urlObj.toString();
    }
    if (preserveHash && window.location.hash) {
      finalUrl += window.location.hash;
    }
    if (delay2 > 0) {
      setTimeout(() => {
        window.location.href = finalUrl;
      }, delay2);
    } else {
      window.location.href = finalUrl;
    }
  }
  /**
   * Check if current user should be redirected and perform redirect if needed
   */
  checkAndRedirect(userRole, options = {}) {
    if (shouldRedirectUser(userRole)) {
      this.redirectByRole(userRole, options);
      return true;
    }
    return false;
  }
  /**
   * Get the URL for a specific role without performing redirect
   */
  getRoleUrl(userRole) {
    return getRedirectUrl(userRole);
  }
  /**
   * Get the URL for a specific app without performing redirect
   */
  getAppUrl(appKey) {
    return appKey === "o7c-hub" ? false ? "https://o7c-hub.vercel.app" : "http://localhost:3000" : false ? "https://player-portal.vercel.app" : "http://localhost:3001";
  }
};
var authRedirect = AuthRedirectService.getInstance();

// shared/utils/errorHandler.js
var import_react6 = __toESM(require_react());
var ERROR_TYPES = {
  NETWORK: "NETWORK",
  API: "API",
  AUTHENTICATION: "AUTHENTICATION",
  AUTHORIZATION: "AUTHORIZATION",
  VALIDATION: "VALIDATION",
  SERVER: "SERVER",
  CLIENT: "CLIENT",
  UNKNOWN: "UNKNOWN"
};
var STATUS_ERROR_MAP = {
  400: ERROR_TYPES.VALIDATION,
  401: ERROR_TYPES.AUTHENTICATION,
  403: ERROR_TYPES.AUTHORIZATION,
  404: ERROR_TYPES.API,
  422: ERROR_TYPES.VALIDATION,
  429: ERROR_TYPES.API,
  500: ERROR_TYPES.SERVER,
  502: ERROR_TYPES.SERVER,
  503: ERROR_TYPES.SERVER,
  504: ERROR_TYPES.SERVER
};
var NETWORK_ERRORS = [
  "NetworkError",
  "TypeError",
  "fetch",
  "network",
  "timeout",
  "ECONNRESET",
  "ENOTFOUND",
  "ECONNREFUSED"
];
function categorizeError(error, status) {
  if (status && STATUS_ERROR_MAP[status]) {
    return STATUS_ERROR_MAP[status];
  }
  if (error && typeof error.message === "string") {
    const message = error.message.toLowerCase();
    if (NETWORK_ERRORS.some((pattern) => message.includes(pattern.toLowerCase()))) {
      return ERROR_TYPES.NETWORK;
    }
  }
  if (error && error.message) {
    const message = error.message.toLowerCase();
    if (message.includes("unauthorized") || message.includes("invalid token")) {
      return ERROR_TYPES.AUTHENTICATION;
    }
    if (message.includes("forbidden") || message.includes("access denied")) {
      return ERROR_TYPES.AUTHORIZATION;
    }
  }
  if (error && (error.name === "ApiError" || error.status)) {
    return ERROR_TYPES.API;
  }
  return ERROR_TYPES.UNKNOWN;
}
function getUserFriendlyMessage(errorType, originalMessage = "") {
  const messages = {
    [ERROR_TYPES.NETWORK]: "Unable to connect to the server. Please check your internet connection and try again.",
    [ERROR_TYPES.API]: "The service is temporarily unavailable. Please try again in a few moments.",
    [ERROR_TYPES.AUTHENTICATION]: "Your session has expired. Please sign in again.",
    [ERROR_TYPES.AUTHORIZATION]: "You don't have permission to perform this action.",
    [ERROR_TYPES.VALIDATION]: "Please check your input and try again.",
    [ERROR_TYPES.SERVER]: "The server is experiencing issues. Please try again later.",
    [ERROR_TYPES.CLIENT]: "Something went wrong on our end. Please try again.",
    [ERROR_TYPES.UNKNOWN]: "An unexpected error occurred. Please try again or contact support if the issue persists."
  };
  return messages[errorType] || messages[ERROR_TYPES.UNKNOWN];
}
function getFallbackActions(errorType) {
  const actions = {
    [ERROR_TYPES.NETWORK]: [
      { label: "Retry", action: "retry", primary: true },
      { label: "Check Connection", action: "checkConnection" }
    ],
    [ERROR_TYPES.API]: [
      { label: "Try Again", action: "retry", primary: true },
      { label: "Refresh Page", action: "refresh" }
    ],
    [ERROR_TYPES.AUTHENTICATION]: [
      { label: "Sign In", action: "login", primary: true },
      { label: "Go Home", action: "home" }
    ],
    [ERROR_TYPES.AUTHORIZATION]: [
      { label: "Go Back", action: "back", primary: true },
      { label: "Contact Support", action: "support" }
    ],
    [ERROR_TYPES.VALIDATION]: [
      { label: "Fix Errors", action: "fix", primary: true },
      { label: "Reset Form", action: "reset" }
    ],
    [ERROR_TYPES.SERVER]: [
      { label: "Try Again", action: "retry", primary: true },
      { label: "Contact Support", action: "support" }
    ],
    [ERROR_TYPES.CLIENT]: [
      { label: "Refresh Page", action: "refresh", primary: true },
      { label: "Clear Cache", action: "clearCache" }
    ],
    [ERROR_TYPES.UNKNOWN]: [
      { label: "Try Again", action: "retry", primary: true },
      { label: "Contact Support", action: "support" }
    ]
  };
  return actions[errorType] || actions[ERROR_TYPES.UNKNOWN];
}
function handleApiError(error, context = {}) {
  const errorType = categorizeError(error, error.status);
  const userMessage = getUserFriendlyMessage(errorType, error.message);
  const fallbackActions = getFallbackActions(errorType);
  const errorInfo = {
    type: errorType,
    message: error.message,
    stack: error.stack,
    status: error.status,
    context,
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    userAgent: typeof navigator !== "undefined" ? navigator.userAgent : "",
    url: typeof window !== "undefined" ? window.location.href : ""
  };
  console.error("API Error:", errorInfo);
  if (typeof window !== "undefined" && typeof sessionStorage !== "undefined") {
    const errors = JSON.parse(sessionStorage.getItem("app_errors") || "[]");
    errors.push(errorInfo);
    if (errors.length > 20) {
      errors.splice(0, errors.length - 20);
    }
    sessionStorage.setItem("app_errors", JSON.stringify(errors));
  }
  return {
    type: errorType,
    message: userMessage,
    originalError: error,
    actions: fallbackActions,
    canRetry: [ERROR_TYPES.NETWORK, ERROR_TYPES.API, ERROR_TYPES.SERVER].includes(errorType),
    shouldLogout: errorType === ERROR_TYPES.AUTHENTICATION,
    errorId: `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  };
}

// shared/services/chatService.ts
var ChatService = class {
  constructor(config) {
    this.eventListeners = /* @__PURE__ */ new Map();
    this.config = config;
  }
  // Room Management
  async createRoom(name, type, participants, createdBy, metadata) {
    try {
      const roomData = {
        name,
        type,
        participants: participants.map((userId) => ({
          userId,
          joinedAt: serverTimestamp(),
          isOnline: false
        })),
        createdAt: serverTimestamp(),
        createdBy,
        lastActivity: serverTimestamp(),
        isActive: true,
        metadata: metadata || {}
      };
      const docRef = await addDoc(collection(db, "chatRooms"), roomData);
      return docRef.id;
    } catch (error) {
      throw handleApiError(error, { operation: "createRoom", context: "ChatService" });
    }
  }
  async joinRoom(roomId, userId, userName, role) {
    try {
      const roomRef = doc(db, "chatRooms", roomId);
      const roomSnap = await getDoc(roomRef);
      if (!roomSnap.exists()) {
        const error = new Error("Room not found");
        error.status = 404;
        throw error;
      }
      const roomData = roomSnap.data();
      const participantIndex = roomData.participants.findIndex((p) => p.userId === userId);
      if (participantIndex === -1) {
        roomData.participants.push({
          userId,
          userName,
          role,
          joinedAt: serverTimestamp(),
          isOnline: true,
          lastSeen: serverTimestamp()
        });
      } else {
        roomData.participants[participantIndex].isOnline = true;
        roomData.participants[participantIndex].lastSeen = serverTimestamp();
      }
      await updateDoc(roomRef, {
        participants: roomData.participants,
        lastActivity: serverTimestamp()
      });
      await this.updatePresence(userId, true, roomId);
    } catch (error) {
      throw handleApiError(error, { operation: "joinRoom", roomId, context: "ChatService" });
    }
  }
  async leaveRoom(roomId, userId) {
    const roomRef = doc(db, "chatRooms", roomId);
    const roomSnap = await getDoc(roomRef);
    if (!roomSnap.exists()) {
      return;
    }
    const roomData = roomSnap.data();
    const participantIndex = roomData.participants.findIndex((p) => p.userId === userId);
    if (participantIndex !== -1) {
      roomData.participants[participantIndex].isOnline = false;
      roomData.participants[participantIndex].lastSeen = serverTimestamp();
      await updateDoc(roomRef, {
        participants: roomData.participants,
        lastActivity: serverTimestamp()
      });
    }
    await this.updatePresence(userId, false);
  }
  // Message Management
  async sendMessage(roomId, senderId, senderName, content, type = "text", replyTo) {
    const messageData = {
      chatId: roomId,
      senderId,
      senderName,
      content: this.encryptMessage(content),
      timestamp: serverTimestamp(),
      type,
      replyTo,
      edited: false
    };
    const docRef = await addDoc(collection(db, "chatMessages"), messageData);
    await updateDoc(doc(db, "chatRooms", roomId), {
      lastMessage: {
        id: docRef.id,
        ...messageData,
        timestamp: serverTimestamp()
      },
      lastActivity: serverTimestamp()
    });
    return docRef.id;
  }
  async editMessage(messageId, content) {
    await updateDoc(doc(db, "chatMessages", messageId), {
      content: this.encryptMessage(content),
      edited: true,
      editedAt: serverTimestamp()
    });
  }
  async deleteMessage(messageId) {
    await deleteDoc(doc(db, "chatMessages", messageId));
  }
  // File Upload
  async uploadFile(roomId, file, senderId) {
    if (this.config.maxFileSize && file.size > this.config.maxFileSize) {
      throw new Error(`File size exceeds maximum allowed size of ${this.config.maxFileSize} bytes`);
    }
    if (this.config.allowedFileTypes && !this.config.allowedFileTypes.includes(file.type)) {
      throw new Error(`File type ${file.type} is not allowed`);
    }
    const fileRef = ref(storage, `chat/${roomId}/${Date.now()}_${file.name}`);
    await uploadBytes(fileRef, file);
    return getDownloadURL(fileRef);
  }
  // Real-time Subscriptions
  subscribeToRoom(roomId, callback) {
    const q = query(
      collection(db, "chatMessages"),
      where("chatId", "==", roomId),
      orderBy("timestamp", "desc"),
      limit(50)
    );
    const unsubscribe = onSnapshot(q, (snapshot) => {
      const messages = snapshot.docs.map((doc2) => {
        var _a;
        return {
          id: doc2.id,
          ...doc2.data(),
          timestamp: ((_a = doc2.data().timestamp) == null ? void 0 : _a.toDate()) || /* @__PURE__ */ new Date(),
          content: this.decryptMessage(doc2.data().content)
        };
      });
      callback(messages.reverse());
    });
    return unsubscribe;
  }
  subscribeToRoomUpdates(roomId, callback) {
    const unsubscribe = onSnapshot(doc(db, "chatRooms", roomId), (snapshot) => {
      var _a, _b, _c;
      if (snapshot.exists()) {
        const data = snapshot.data();
        const room = {
          id: snapshot.id,
          name: data.name,
          type: data.type,
          participants: data.participants || [],
          createdAt: ((_a = data.createdAt) == null ? void 0 : _a.toDate()) || /* @__PURE__ */ new Date(),
          createdBy: data.createdBy,
          lastActivity: ((_b = data.lastActivity) == null ? void 0 : _b.toDate()) || /* @__PURE__ */ new Date(),
          lastMessage: data.lastMessage ? {
            ...data.lastMessage,
            timestamp: ((_c = data.lastMessage.timestamp) == null ? void 0 : _c.toDate()) || /* @__PURE__ */ new Date(),
            content: this.decryptMessage(data.lastMessage.content)
          } : void 0,
          isActive: data.isActive,
          metadata: data.metadata
        };
        callback(room);
      }
    });
    return unsubscribe;
  }
  subscribeToPresence(callback) {
    const unsubscribe = onSnapshot(collection(db, "userPresence"), (snapshot) => {
      const presences = snapshot.docs.map((doc2) => {
        var _a;
        return {
          ...doc2.data(),
          lastSeen: ((_a = doc2.data().lastSeen) == null ? void 0 : _a.toDate()) || /* @__PURE__ */ new Date()
        };
      });
      callback(presences);
    });
    return unsubscribe;
  }
  // Presence Management
  async updatePresence(userId, isOnline, currentRoom) {
    const presenceRef = doc(db, "userPresence", userId);
    await setDoc(presenceRef, {
      userId,
      isOnline,
      lastSeen: serverTimestamp(),
      currentRoom
    }, { merge: true });
  }
  // Permissions
  async getPermissions(userId, roomId) {
    const roomSnap = await getDoc(doc(db, "chatRooms", roomId));
    if (!roomSnap.exists()) {
      return {
        canSendMessages: false,
        canEditMessages: false,
        canDeleteMessages: false,
        canAddParticipants: false,
        canRemoveParticipants: false,
        canViewHistory: false
      };
    }
    const room = roomSnap.data();
    const participant = room.participants.find((p) => p.userId === userId);
    if (!participant) {
      return {
        canSendMessages: false,
        canEditMessages: false,
        canDeleteMessages: false,
        canAddParticipants: false,
        canRemoveParticipants: false,
        canViewHistory: false
      };
    }
    const isAdmin = participant.role === "admin";
    const isCoach = participant.role === "coach";
    const isPlayer = participant.role === "player";
    const isParent = participant.role === "parent";
    return {
      canSendMessages: true,
      canEditMessages: isAdmin || isCoach,
      canDeleteMessages: isAdmin,
      canAddParticipants: isAdmin || isCoach,
      canRemoveParticipants: isAdmin,
      canViewHistory: true
    };
  }
  // Encryption/Decryption (basic implementation - enhance for production)
  encryptMessage(content) {
    if (!this.config.encryptionKey) return content;
    return btoa(content);
  }
  decryptMessage(content) {
    if (!this.config.encryptionKey) return content;
    try {
      return atob(content);
    } catch {
      return content;
    }
  }
  // Event System
  on(eventType, callback) {
    this.eventListeners.set(eventType, callback);
  }
  off(eventType) {
    this.eventListeners.delete(eventType);
  }
  emitEvent(event) {
    const listener = this.eventListeners.get(event.type);
    if (listener) {
      listener(event);
    }
  }
  // Cleanup
  async cleanupInactiveRooms() {
    const thirtyDaysAgo = /* @__PURE__ */ new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    const q = query(
      collection(db, "chatRooms"),
      where("lastActivity", "<", Timestamp.fromDate(thirtyDaysAgo)),
      where("isActive", "==", true)
    );
    const snapshot = await getDocs(q);
    const batch = writeBatch(db);
    snapshot.docs.forEach((doc2) => {
      batch.update(doc2.ref, { isActive: false });
    });
    await batch.commit();
  }
};

// shared/services/notificationService.ts
var NotificationService = class {
  constructor(userId) {
    this.userId = userId;
  }
  // Create notification
  async createNotification(chatId, messageId, type, fromUserId) {
    if (fromUserId === this.userId) return;
    const notificationData = {
      userId: this.userId,
      chatId,
      messageId,
      type,
      isRead: false,
      createdAt: /* @__PURE__ */ new Date()
    };
    await addDoc(collection(db, "chatNotifications"), notificationData);
  }
  // Get notifications
  subscribeToNotifications(callback) {
    const q = query(
      collection(db, "chatNotifications"),
      where("userId", "==", this.userId),
      orderBy("createdAt", "desc")
    );
    const unsubscribe = onSnapshot(q, (snapshot) => {
      const notifications = snapshot.docs.map((doc2) => {
        var _a;
        return {
          id: doc2.id,
          ...doc2.data(),
          createdAt: ((_a = doc2.data().createdAt) == null ? void 0 : _a.toDate()) || /* @__PURE__ */ new Date()
        };
      });
      callback(notifications);
    });
    return unsubscribe;
  }
  // Mark notification as read
  async markAsRead(notificationId) {
    await updateDoc(doc(db, "chatNotifications", notificationId), {
      isRead: true
    });
  }
  // Mark all notifications as read for a chat
  async markChatAsRead(chatId) {
    const q = query(
      collection(db, "chatNotifications"),
      where("userId", "==", this.userId),
      where("chatId", "==", chatId),
      where("isRead", "==", false)
    );
    const querySnapshot = await getDocs(q);
    const updatePromises = [];
    querySnapshot.forEach((document) => {
      updatePromises.push(updateDoc(document.ref, { isRead: true }));
    });
    await Promise.all(updatePromises);
  }
  // Get unread count
  subscribeToUnreadCount(callback) {
    const q = query(
      collection(db, "chatNotifications"),
      where("userId", "==", this.userId),
      where("isRead", "==", false)
    );
    const unsubscribe = onSnapshot(q, (snapshot) => {
      callback(snapshot.size);
    });
    return unsubscribe;
  }
  // Browser notification (if permission granted)
  async showBrowserNotification(title, body, chatId) {
    if ("Notification" in window && Notification.permission === "granted") {
      const notification = new Notification(title, {
        body,
        icon: "/o7clogo.png",
        // Update with your app icon
        tag: chatId
        // Prevents duplicate notifications
      });
      notification.onclick = () => {
        window.focus();
        notification.close();
      };
    }
  }
  // Request notification permission
  async requestPermission() {
    if (!("Notification" in window)) {
      return false;
    }
    if (Notification.permission === "granted") {
      return true;
    }
    if (Notification.permission !== "denied") {
      const permission = await Notification.requestPermission();
      return permission === "granted";
    }
    return false;
  }
};

// shared/middleware/auth.ts
var createAuthMiddleware = (options = {}) => {
  return (req, res, next) => {
    try {
      if (!req.user) {
        return res.status(401).json({
          error: "Authentication required",
          message: "You must be logged in to access this resource"
        });
      }
      if (options.requiredRoles && options.requiredRoles.length > 0) {
        const hasRequiredRole = options.requireAllRoles ? options.requiredRoles.every((role) => req.user.role === role) : options.requiredRoles.includes(req.user.role);
        if (!hasRequiredRole) {
          return res.status(403).json({
            error: "Insufficient permissions",
            message: "Your role does not have access to this resource"
          });
        }
      }
      if (options.requiredPermissions && options.requiredPermissions.length > 0) {
        console.warn("Permission checking not yet implemented in middleware");
      }
      next();
    } catch (error) {
      console.error("Auth middleware error:", error);
      return res.status(500).json({
        error: "Internal server error",
        message: "An error occurred while checking authentication"
      });
    }
  };
};
var requireAdmin = createAuthMiddleware({ requiredRoles: ["admin"] });
var requireCoach = createAuthMiddleware({ requiredRoles: ["admin", "coach"] });
var requirePlayer = createAuthMiddleware({ requiredRoles: ["player", "parent"] });
var requireParent = createAuthMiddleware({ requiredRoles: ["parent"] });
var requireAuthenticated = createAuthMiddleware();
export {
  APP_CONFIGS,
  AccessDenied_default as AccessDenied,
  AdditionalFee,
  ApiError,
  AuthProvider,
  AuthRedirectService,
  Button,
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  ChatService,
  ChatSystem,
  Coach,
  CoachAssignment,
  Contact,
  Core,
  CreateFileSignedUrl,
  ErrorMessage_default as ErrorMessage,
  ExtractDataFromUploadedFile,
  GenerateImage,
  InvokeLLM,
  LoadingSpinner_default as LoadingSpinner,
  NotificationService,
  PERMISSIONS,
  ParentPlayerAssignment,
  Payment,
  PaymentMethod,
  Player,
  PlayerImage,
  ProtectedRoute_default as ProtectedRoute,
  RateLimiter,
  RecruitingInterest,
  School,
  SendEmail,
  Team,
  TeamFee,
  TeamHistory,
  Tournament,
  TournamentParticipation,
  UploadFile,
  UploadPrivateFile,
  User2 as User,
  analytics,
  apiClient,
  auth,
  authRedirect,
  base44,
  canPerformAction,
  checkAppAccess,
  cn,
  createAuthMiddleware,
  db,
  firebaseClient,
  getAllowedRoles,
  getAppForRole,
  getCurrentApp,
  getRedirectUrl,
  getRedirectUrlForRole,
  hasAccessToApp,
  hasAllPermissions,
  hasAnyPermission,
  hasPermission,
  isAuthenticated,
  isValidEmail,
  me,
  requireAdmin,
  requireAuthenticated,
  requireCoach,
  requireParent,
  requirePlayer,
  sanitizeInput,
  shouldRedirectUser,
  useAuth,
  useChat,
  useOfflineQueue,
  usePresence,
  validateApiAccess
};
//# sourceMappingURL=@o7c_shared.js.map
